!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ALLOC	.\include\mem.h	14;"	d
AP_INCLUDED	.\include\ap.h	3;"	d
AP_add	.\src\ap.c	/^T AP_add(T x, T y) {$/;"	f
AP_addi	.\src\ap.c	/^T AP_addi(T x, long int y) {$/;"	f
AP_cmp	.\src\ap.c	/^int AP_cmp(T x, T y) {$/;"	f
AP_cmpi	.\src\ap.c	/^int AP_cmpi(T x, long int y) {$/;"	f
AP_div	.\src\ap.c	/^T AP_div(T x, T y) {$/;"	f
AP_divi	.\src\ap.c	/^T AP_divi(T x, long int y) {$/;"	f
AP_fmt	.\src\ap.c	/^void AP_fmt(int code, va_list_box *box,$/;"	f
AP_free	.\src\ap.c	/^void AP_free(T *z) {$/;"	f
AP_fromstr	.\src\ap.c	/^T AP_fromstr(const char *str, int base, char **end) {$/;"	f
AP_lshift	.\src\ap.c	/^T AP_lshift(T x, int s) {$/;"	f
AP_mod	.\src\ap.c	/^T AP_mod(T x, T y) {$/;"	f
AP_modi	.\src\ap.c	/^long int AP_modi(T x, long int y) {$/;"	f
AP_mul	.\src\ap.c	/^T AP_mul(T x, T y) {$/;"	f
AP_muli	.\src\ap.c	/^T AP_muli(T x, long int y) {$/;"	f
AP_neg	.\src\ap.c	/^T AP_neg(T x) {$/;"	f
AP_new	.\src\ap.c	/^T AP_new(long int n) {$/;"	f
AP_pow	.\src\ap.c	/^T AP_pow(T x, T y, T p) {$/;"	f
AP_rshift	.\src\ap.c	/^T AP_rshift(T x, int s) {$/;"	f
AP_sub	.\src\ap.c	/^T AP_sub(T x, T y) {$/;"	f
AP_subi	.\src\ap.c	/^T AP_subi(T x, long int y) {$/;"	f
AP_toint	.\src\ap.c	/^long int AP_toint(T x) {$/;"	f
AP_tostr	.\src\ap.c	/^char *AP_tostr(char *str, int size, int base, T x) {$/;"	f
ARENA_INCLUDED	.\include\arena.h	3;"	d
ARRAYREP_INCLUDED	.\include\arrayrep.h	3;"	d
ARRAY_INCLUDED	.\include\array.h	3;"	d
ATOM_INCLUDED	.\include\atom.h	3;"	d
Arena_Failed	.\src\arena.c	/^const Except_T Arena_Failed    =$/;"	v
Arena_NewFailed	.\src\arena.c	/^const Except_T Arena_NewFailed =$/;"	v
Arena_alloc	.\src\arena.c	/^void *Arena_alloc(T arena, long nbytes,$/;"	f
Arena_calloc	.\src\arena.c	/^void *Arena_calloc(T arena, long count, long nbytes,$/;"	f
Arena_dispose	.\src\arena.c	/^void Arena_dispose(T *ap) {$/;"	f
Arena_free	.\src\arena.c	/^void Arena_free(T arena) {$/;"	f
Arena_new	.\src\arena.c	/^T Arena_new(void) {$/;"	f
Arith_ceiling	.\src\arith.c	/^int Arith_ceiling(int x, int y) {$/;"	f
Arith_div	.\src\arith.c	/^int Arith_div(int x, int y) {$/;"	f
Arith_floor	.\src\arith.c	/^int Arith_floor(int x, int y) {$/;"	f
Arith_max	.\src\arith.c	/^int Arith_max(int x, int y) {$/;"	f
Arith_min	.\src\arith.c	/^int Arith_min(int x, int y) {$/;"	f
Arith_mod	.\src\arith.c	/^int Arith_mod(int x, int y) {$/;"	f
ArrayRep_init	.\src\array.c	/^void ArrayRep_init(T array, int length, int size,$/;"	f
Array_copy	.\src\array.c	/^T Array_copy(T array, int length) {$/;"	f
Array_free	.\src\array.c	/^void Array_free(T *array) {$/;"	f
Array_get	.\src\array.c	/^void *Array_get(T array, int i) {$/;"	f
Array_length	.\src\array.c	/^int Array_length(T array) {$/;"	f
Array_new	.\src\array.c	/^T Array_new(int length, int size) {$/;"	f
Array_put	.\src\array.c	/^void *Array_put(T array, int i, void *elem) {$/;"	f
Array_resize	.\src\array.c	/^void Array_resize(T array, int length) {$/;"	f
Array_size	.\src\array.c	/^int Array_size(T array) {$/;"	f
Assert_Failed	.\src\assert.c	/^const Except_T Assert_Failed = { "Assertion failed" };$/;"	v
Atom_int	.\src\atom.c	/^const char *Atom_int(long n) {$/;"	f
Atom_length	.\src\atom.c	/^int Atom_length(const char *str) {$/;"	f
Atom_new	.\src\atom.c	/^const char *Atom_new(const char *str, int len) {$/;"	f
Atom_string	.\src\atom.c	/^const char *Atom_string(const char *str) {$/;"	f
BASE	.\src\mp.c	16;"	d	file:
BASE	.\src\xp.c	7;"	d	file:
BIT_INCLUDED	.\include\bit.h	3;"	d
BPW	.\src\bit.c	13;"	d	file:
Bit_clear	.\src\bit.c	/^void Bit_clear(T set, int lo, int hi) {$/;"	f
Bit_count	.\src\bit.c	/^int Bit_count(T set) {$/;"	f
Bit_diff	.\src\bit.c	/^T Bit_diff(T s, T t) {$/;"	f
Bit_eq	.\src\bit.c	/^int Bit_eq(T s, T t) {$/;"	f
Bit_free	.\src\bit.c	/^void Bit_free(T *set) {$/;"	f
Bit_get	.\src\bit.c	/^int Bit_get(T set, int n) {$/;"	f
Bit_inter	.\src\bit.c	/^T Bit_inter(T s, T t) {$/;"	f
Bit_length	.\src\bit.c	/^int Bit_length(T set) {$/;"	f
Bit_leq	.\src\bit.c	/^int Bit_leq(T s, T t) {$/;"	f
Bit_lt	.\src\bit.c	/^int Bit_lt(T s, T t) {$/;"	f
Bit_map	.\src\bit.c	/^void Bit_map(T set,$/;"	f
Bit_minus	.\src\bit.c	/^T Bit_minus(T s, T t) {$/;"	f
Bit_new	.\src\bit.c	/^T Bit_new(int length) {$/;"	f
Bit_not	.\src\bit.c	/^void Bit_not(T set, int lo, int hi) {$/;"	f
Bit_put	.\src\bit.c	/^int Bit_put(T set, int n, int bit) {$/;"	f
Bit_set	.\src\bit.c	/^void Bit_set(T set, int lo, int hi) {$/;"	f
Bit_union	.\src\bit.c	/^T Bit_union(T s, T t) {$/;"	f
CALLOC	.\include\mem.h	16;"	d
CHAN_INCLUDED	.\include\chan.h	3;"	d
Chan_new	.\src\chan.c	/^T Chan_new(void) {$/;"	f
Chan_receive	.\src\chan.c	/^int Chan_receive(Chan_T c, void *ptr, int size) {$/;"	f
Chan_send	.\src\chan.c	/^int Chan_send(Chan_T c, const void *ptr, int size) {$/;"	f
ELSE	.\include\except.h	48;"	d
ELSE	.\include\except.h	77;"	d
END_LOCK	.\include\sem.h	11;"	d
END_TRY	.\include\except.h	57;"	d
END_TRY	.\include\except.h	86;"	d
ENTERCRITICAL	.\src\thread-nt.c	40;"	d	file:
EXCEPT	.\include\except.h	44;"	d
EXCEPT	.\include\except.h	73;"	d
EXCEPT_INCLUDED	.\include\except.h	3;"	d
Except_Frame	.\include\except.h	/^struct Except_Frame {$/;"	s
Except_Frame	.\include\except.h	/^typedef struct Except_Frame Except_Frame;$/;"	t	typeref:struct:Except_Frame
Except_entered	.\include\except.h	/^enum { Except_entered=0, Except_raised,$/;"	e	enum:__anon2
Except_finalized	.\include\except.h	/^       Except_handled,   Except_finalized };$/;"	e	enum:__anon2
Except_handled	.\include\except.h	/^       Except_handled,   Except_finalized };$/;"	e	enum:__anon2
Except_index	.\src\except.c	/^int Except_index = -1;$/;"	v
Except_init	.\src\except.c	/^void Except_init(void) {$/;"	f
Except_pop	.\src\except.c	/^void Except_pop(void) {$/;"	f
Except_push	.\src\except.c	/^void Except_push(Except_Frame *fp) {$/;"	f
Except_raise	.\src\except.c	/^void Except_raise(const T *e, const char *file,$/;"	f
Except_raised	.\include\except.h	/^enum { Except_entered=0, Except_raised,$/;"	e	enum:__anon2
Except_stack	.\src\except.c	/^Except_Frame *Except_stack = NULL;$/;"	v
FINALLY	.\include\except.h	52;"	d
FINALLY	.\include\except.h	81;"	d
FMT_INCLUDED	.\include\fmt.h	3;"	d
FREE	.\include\mem.h	20;"	d
Fmt_Overflow	.\src\fmt.c	/^const Except_T Fmt_Overflow = { "Formatting Overflow" };$/;"	v
Fmt_flags	.\src\fmt.c	/^char *Fmt_flags = "-+ 0";$/;"	v
Fmt_fmt	.\src\fmt.c	/^void Fmt_fmt(int put(int c, void *), void *cl,$/;"	f
Fmt_fprint	.\src\fmt.c	/^void Fmt_fprint(FILE *stream, const char *fmt, ...) {$/;"	f
Fmt_print	.\examples\sort.c	15;"	d	file:
Fmt_print	.\src\fmt.c	/^void Fmt_print(const char *fmt, ...) {$/;"	f
Fmt_putd	.\src\fmt.c	/^void Fmt_putd(const char *str, int len,$/;"	f
Fmt_puts	.\src\fmt.c	/^void Fmt_puts(const char *str, int len,$/;"	f
Fmt_register	.\src\fmt.c	/^T Fmt_register(int code, T newcvt) {$/;"	f
Fmt_sfmt	.\src\fmt.c	/^int Fmt_sfmt(char *buf, int size, const char *fmt, ...) {$/;"	f
Fmt_string	.\src\fmt.c	/^char *Fmt_string(const char *fmt, ...) {$/;"	f
Fmt_vfmt	.\src\fmt.c	/^void Fmt_vfmt(int put(int c, void *cl), void *cl,$/;"	f
Fmt_vsfmt	.\src\fmt.c	/^int Fmt_vsfmt(char *buf, int size, const char *fmt,$/;"	f
Fmt_vstring	.\src\fmt.c	/^char *Fmt_vstring(const char *fmt, va_list_box *box) {$/;"	f
HASH	.\src\thread-nt.c	32;"	d	file:
IDThread	.\src\thread-nt.c	/^	DWORD IDThread;		\/* Win 32 thread identifier *\/$/;"	m	struct:T	file:
INTEGER_INCLUDED	.\examples\integer.h	2;"	d
Integer_cmp	.\examples\integer.c	/^int Integer_cmp(T i1, T i2) {$/;"	f
Integer_fmt	.\examples\integer.c	/^void Integer_fmt(int code, va_list_box *box,$/;"	f
Integer_get	.\examples\integer.c	/^int Integer_get(T integer) {$/;"	f
Integer_new	.\examples\integer.c	/^T Integer_new(int n) {$/;"	f
Integer_put	.\examples\integer.c	/^int Integer_put(T integer, int n) {$/;"	f
LEAVECRITICAL	.\src\thread-nt.c	41;"	d	file:
LIST_INCLUDED	.\include\list.h	3;"	d
LOCK	.\include\sem.h	9;"	d
List_append	.\src\list.c	/^T List_append(T list, T tail) {$/;"	f
List_copy	.\src\list.c	/^T List_copy(T list) {$/;"	f
List_free	.\src\list.c	/^void List_free(T *list) {$/;"	f
List_length	.\src\list.c	/^int List_length(T list) {$/;"	f
List_list	.\src\list.c	/^T List_list(void *x, ...) {$/;"	f
List_map	.\src\list.c	/^void List_map(T list,$/;"	f
List_pop	.\src\list.c	/^T List_pop(T list, void **x) {$/;"	f
List_push	.\src\list.c	/^T List_push(T list, void *x) {$/;"	f
List_reverse	.\src\list.c	/^T List_reverse(T list) {$/;"	f
List_toArray	.\src\list.c	/^void **List_toArray(T list, void *end) {$/;"	f
MEM_INCLUDED	.\include\mem.h	3;"	d
MP_Dividebyzero	.\src\mp.c	/^const Except_T MP_Dividebyzero = { "Division by zero" };$/;"	v
MP_INCLUDED	.\include\mp.h	3;"	d
MP_Overflow	.\src\mp.c	/^const Except_T MP_Overflow     = { "Overflow" };$/;"	v
MP_add	.\src\mp.c	/^T MP_add(T z, T x, T y) {$/;"	f
MP_addi	.\src\mp.c	/^T MP_addi(T z, T x, long y) {$/;"	f
MP_addu	.\src\mp.c	/^T MP_addu(T z, T x, T y) {$/;"	f
MP_addui	.\src\mp.c	/^T MP_addui(T z, T x, unsigned long y) {$/;"	f
MP_and	.\src\mp.c	/^T MP_and(T z, T x, T y) { bitop(&); }$/;"	f
MP_andi	.\src\mp.c	/^T MP_andi(T z, T x, unsigned long y) { bitopi(MP_and); }$/;"	f
MP_ashift	.\src\mp.c	/^T MP_ashift(T z, T x, int s) { shft(sign(x),XP_rshift); }$/;"	f
MP_cmp	.\src\mp.c	/^int MP_cmp(T x, T y) {$/;"	f
MP_cmpi	.\src\mp.c	/^int MP_cmpi(T x, long y) {$/;"	f
MP_cmpu	.\src\mp.c	/^int MP_cmpu(T x, T y) {$/;"	f
MP_cmpui	.\src\mp.c	/^int MP_cmpui(T x, unsigned long y) {$/;"	f
MP_cvt	.\src\mp.c	/^T MP_cvt(int m, T z, T x) {$/;"	f
MP_cvtu	.\src\mp.c	/^T MP_cvtu(int m, T z, T x) {$/;"	f
MP_div	.\src\mp.c	/^T MP_div(T z, T x, T y) {$/;"	f
MP_divi	.\src\mp.c	/^T MP_divi(T z, T x, long y) {$/;"	f
MP_divu	.\src\mp.c	/^T MP_divu(T z, T x, T y) {$/;"	f
MP_divui	.\src\mp.c	/^T MP_divui(T z, T x, unsigned long y) {$/;"	f
MP_fmt	.\src\mp.c	/^void MP_fmt(int code, va_list_box *box,$/;"	f
MP_fmtu	.\src\mp.c	/^void MP_fmtu(int code, va_list_box *box,$/;"	f
MP_fromint	.\src\mp.c	/^T MP_fromint(T z, long v) {$/;"	f
MP_fromintu	.\src\mp.c	/^T MP_fromintu(T z, unsigned long u) {$/;"	f
MP_fromstr	.\src\mp.c	/^T MP_fromstr(T z, const char *str, int base, char **end){$/;"	f
MP_lshift	.\src\mp.c	/^T MP_lshift(T z, T x, int s) { shft(0, XP_lshift); }$/;"	f
MP_mod	.\src\mp.c	/^T MP_mod(T z, T x, T y) {$/;"	f
MP_modi	.\src\mp.c	/^long MP_modi(T x, long y) {$/;"	f
MP_modu	.\src\mp.c	/^T MP_modu(T z, T x, T y) {$/;"	f
MP_modui	.\src\mp.c	/^unsigned long MP_modui(T x, unsigned long y) {$/;"	f
MP_mul	.\src\mp.c	/^T MP_mul(T z, T x, T y) {$/;"	f
MP_mul2	.\src\mp.c	/^T MP_mul2(T z, T x, T y) {$/;"	f
MP_mul2u	.\src\mp.c	/^T MP_mul2u(T z, T x, T y) {$/;"	f
MP_muli	.\src\mp.c	/^T MP_muli(T z, T x, long y) {$/;"	f
MP_mulu	.\src\mp.c	/^T MP_mulu(T z, T x, T y) {$/;"	f
MP_mului	.\src\mp.c	/^T MP_mului(T z, T x, unsigned long y) {$/;"	f
MP_neg	.\src\mp.c	/^T MP_neg(T z, T x) {$/;"	f
MP_new	.\src\mp.c	/^T MP_new(unsigned long u) {$/;"	f
MP_not	.\src\mp.c	/^T MP_not(T z, T x) {$/;"	f
MP_or	.\src\mp.c	/^T MP_or (T z, T x, T y) { bitop(|); }$/;"	f
MP_ori	.\src\mp.c	/^T MP_ori (T z, T x, unsigned long y) { bitopi(MP_or);  }$/;"	f
MP_rshift	.\src\mp.c	/^T MP_rshift(T z, T x, int s) { shft(0, XP_rshift); }$/;"	f
MP_set	.\src\mp.c	/^int MP_set(int n) {$/;"	f
MP_sub	.\src\mp.c	/^T MP_sub(T z, T x, T y) {$/;"	f
MP_subi	.\src\mp.c	/^T MP_subi(T z, T x, long y) {$/;"	f
MP_subu	.\src\mp.c	/^T MP_subu(T z, T x, T y) {$/;"	f
MP_subui	.\src\mp.c	/^T MP_subui(T z, T x, unsigned long y) {$/;"	f
MP_toint	.\src\mp.c	/^long MP_toint(T x) {$/;"	f
MP_tointu	.\src\mp.c	/^unsigned long MP_tointu(T x) {$/;"	f
MP_tostr	.\src\mp.c	/^char *MP_tostr(char *str, int size, int base, T x) {$/;"	f
MP_xor	.\src\mp.c	/^T MP_xor(T z, T x, T y) { bitop(^); }$/;"	f
MP_xori	.\src\mp.c	/^T MP_xori(T z, T x, unsigned long y) { bitopi(MP_xor); }$/;"	f
Mem_Failed	.\src\mem.c	/^const Except_T Mem_Failed = { "Allocation Failed" };$/;"	v
Mem_Failed	.\src\memchk.c	/^const Except_T Mem_Failed = { "Allocation Failed" };$/;"	v
Mem_alloc	.\src\mem.c	/^void *Mem_alloc(long nbytes, const char *file, int line){$/;"	f
Mem_alloc	.\src\memchk.c	/^void *Mem_alloc(long nbytes, const char *file, int line){$/;"	f
Mem_calloc	.\src\mem.c	/^void *Mem_calloc(long count, long nbytes,$/;"	f
Mem_calloc	.\src\memchk.c	/^void *Mem_calloc(long count, long nbytes,$/;"	f
Mem_free	.\src\mem.c	/^void Mem_free(void *ptr, const char *file, int line) {$/;"	f
Mem_free	.\src\memchk.c	/^void Mem_free(void *ptr, const char *file, int line) {$/;"	f
Mem_resize	.\src\mem.c	/^void *Mem_resize(void *ptr, long nbytes,$/;"	f
Mem_resize	.\src\memchk.c	/^void *Mem_resize(void *ptr, long nbytes,$/;"	f
NALLOC	.\src\memchk.c	24;"	d	file:
NBUMP	.\examples\spin.c	8;"	d	file:
NDESCRIPTORS	.\src\memchk.c	23;"	d	file:
NELEMS	.\src\atom.c	7;"	d	file:
NEW	.\include\mem.h	18;"	d
NEW0	.\include\mem.h	19;"	d
RAISE	.\include\except.h	32;"	d
RAISE	.\include\except.h	62;"	d
RERAISE	.\include\except.h	33;"	d
RERAISE	.\include\except.h	63;"	d
RESIZE	.\include\mem.h	22;"	d
RETURN	.\include\except.h	35;"	d
RETURN	.\include\except.h	65;"	d
RING_INCLUDED	.\include\ring.h	3;"	d
Ring_add	.\src\ring.c	/^void *Ring_add(T ring, int pos, void *x) {$/;"	f
Ring_addhi	.\src\ring.c	/^void *Ring_addhi(T ring, void *x) {$/;"	f
Ring_addlo	.\src\ring.c	/^void *Ring_addlo(T ring, void *x) {$/;"	f
Ring_free	.\src\ring.c	/^void Ring_free(T *ring) {$/;"	f
Ring_get	.\src\ring.c	/^void *Ring_get(T ring, int i) {$/;"	f
Ring_length	.\src\ring.c	/^int Ring_length(T ring) {$/;"	f
Ring_new	.\src\ring.c	/^T Ring_new(void) {$/;"	f
Ring_put	.\src\ring.c	/^void *Ring_put(T ring, int i, void *x) {$/;"	f
Ring_remhi	.\src\ring.c	/^void *Ring_remhi(T ring) {$/;"	f
Ring_remlo	.\src\ring.c	/^void *Ring_remlo(T ring) {$/;"	f
Ring_remove	.\src\ring.c	/^void *Ring_remove(T ring, int i) {$/;"	f
Ring_ring	.\src\ring.c	/^T Ring_ring(void *x, ...) {$/;"	f
Ring_rotate	.\src\ring.c	/^void Ring_rotate(T ring, int n) {$/;"	f
SEM_INCLUDED	.\include\sem.h	3;"	d
SEQ_INCLUDED	.\include\seq.h	3;"	d
SET_INCLUDED	.\include\set.h	3;"	d
STACK_INCLUDED	.\include\stack.h	3;"	d
STR_INCLUDED	.\include\str.h	3;"	d
Sem_init	.\src\thread-nt.c	/^void Sem_init(T *s, int count) {$/;"	f
Sem_init	.\src\thread.c	/^void Sem_init(T *s, int count) {$/;"	f
Sem_new	.\src\thread-nt.c	/^T *Sem_new(int count) {$/;"	f
Sem_new	.\src\thread.c	/^T *Sem_new(int count) {$/;"	f
Sem_signal	.\src\thread-nt.c	/^void Sem_signal(T *s) {$/;"	f
Sem_signal	.\src\thread.c	/^void Sem_signal(T *s) {$/;"	f
Sem_wait	.\src\thread-nt.c	/^void Sem_wait(T *s) {$/;"	f
Sem_wait	.\src\thread.c	/^void Sem_wait(T *s) {$/;"	f
Seq_addhi	.\src\seq.c	/^void *Seq_addhi(T seq, void *x) {$/;"	f
Seq_addlo	.\src\seq.c	/^void *Seq_addlo(T seq, void *x) {$/;"	f
Seq_free	.\src\seq.c	/^void Seq_free(T *seq) {$/;"	f
Seq_get	.\src\seq.c	/^void *Seq_get(T seq, int i) {$/;"	f
Seq_length	.\src\seq.c	/^int Seq_length(T seq) {$/;"	f
Seq_new	.\src\seq.c	/^T Seq_new(int hint) {$/;"	f
Seq_put	.\src\seq.c	/^void *Seq_put(T seq, int i, void *x) {$/;"	f
Seq_remhi	.\src\seq.c	/^void *Seq_remhi(T seq) {$/;"	f
Seq_remlo	.\src\seq.c	/^void *Seq_remlo(T seq) {$/;"	f
Seq_seq	.\src\seq.c	/^T Seq_seq(void *x, ...) {$/;"	f
Set_diff	.\src\set.c	/^T Set_diff(T s, T t) {$/;"	f
Set_free	.\src\set.c	/^void Set_free(T *set) {$/;"	f
Set_inter	.\src\set.c	/^T Set_inter(T s, T t) {$/;"	f
Set_length	.\src\set.c	/^int Set_length(T set) {$/;"	f
Set_map	.\src\set.c	/^void Set_map(T set,$/;"	f
Set_member	.\src\set.c	/^int Set_member(T set, const void *member) {$/;"	f
Set_minus	.\src\set.c	/^T Set_minus(T t, T s) {$/;"	f
Set_new	.\src\set.c	/^T Set_new(int hint,$/;"	f
Set_put	.\src\set.c	/^void Set_put(T set, const void *member) {$/;"	f
Set_remove	.\src\set.c	/^void *Set_remove(T set, const void *member) {$/;"	f
Set_toArray	.\src\set.c	/^void **Set_toArray(T set, void *end) {$/;"	f
Set_union	.\src\set.c	/^T Set_union(T s, T t) {$/;"	f
Stack_empty	.\src\stack.c	/^int Stack_empty(T stk) {$/;"	f
Stack_free	.\src\stack.c	/^void Stack_free(T *stk) {$/;"	f
Stack_new	.\src\stack.c	/^T Stack_new(void) {$/;"	f
Stack_pop	.\src\stack.c	/^void *Stack_pop(T stk) {$/;"	f
Stack_push	.\src\stack.c	/^void Stack_push(T stk, void *x) {$/;"	f
Str_any	.\src\str.c	/^int Str_any(const char *s, int i, const char *set) {$/;"	f
Str_cat	.\src\str.c	/^char *Str_cat(const char *s1, int i1, int j1,$/;"	f
Str_catv	.\src\str.c	/^char *Str_catv(const char *s, ...) {$/;"	f
Str_chr	.\src\str.c	/^int Str_chr(const char *s, int i, int j, int c) {$/;"	f
Str_cmp	.\src\str.c	/^int Str_cmp(const char *s1, int i1, int j1,$/;"	f
Str_dup	.\src\str.c	/^char *Str_dup(const char *s, int i, int j, int n) {$/;"	f
Str_find	.\src\str.c	/^int Str_find(const char *s, int i, int j,$/;"	f
Str_fmt	.\src\str.c	/^void Str_fmt(int code, va_list_box *box,$/;"	f
Str_len	.\src\str.c	/^int Str_len(const char *s, int i, int j) {$/;"	f
Str_many	.\src\str.c	/^int Str_many(const char *s, int i, int j,$/;"	f
Str_map	.\src\str.c	/^char *Str_map(const char *s, int i, int j,$/;"	f
Str_match	.\src\str.c	/^int Str_match(const char *s, int i, int j,$/;"	f
Str_pos	.\src\str.c	/^int Str_pos(const char *s, int i) {$/;"	f
Str_rchr	.\src\str.c	/^int Str_rchr(const char *s, int i, int j, int c) {$/;"	f
Str_reverse	.\src\str.c	/^char *Str_reverse(const char *s, int i, int j) {$/;"	f
Str_rfind	.\src\str.c	/^int Str_rfind(const char *s, int i, int j,$/;"	f
Str_rmany	.\src\str.c	/^int Str_rmany(const char *s, int i, int j,$/;"	f
Str_rmatch	.\src\str.c	/^int Str_rmatch(const char *s, int i, int j,$/;"	f
Str_rupto	.\src\str.c	/^int Str_rupto(const char *s, int i, int j,$/;"	f
Str_sub	.\src\str.c	/^char *Str_sub(const char *s, int i, int j) {$/;"	f
Str_upto	.\src\str.c	/^int Str_upto(const char *s, int i, int j,$/;"	f
T	.\examples\integer.c	/^typedef int *T;$/;"	t	file:
T	.\examples\integer.c	5;"	d	file:
T	.\examples\integer.h	/^typedef int *T;$/;"	t
T	.\examples\integer.h	15;"	d
T	.\examples\integer.h	4;"	d
T	.\include\ap.h	/^typedef struct T *T;$/;"	t	typeref:struct:T
T	.\include\ap.h	34;"	d
T	.\include\ap.h	6;"	d
T	.\include\arena.h	/^typedef struct T *T;$/;"	t	typeref:struct:T
T	.\include\arena.h	16;"	d
T	.\include\arena.h	5;"	d
T	.\include\array.h	/^typedef struct T *T;$/;"	t	typeref:struct:T
T	.\include\array.h	14;"	d
T	.\include\array.h	4;"	d
T	.\include\arrayrep.h	/^struct T {$/;"	s
T	.\include\arrayrep.h	12;"	d
T	.\include\arrayrep.h	4;"	d
T	.\include\bit.h	/^typedef struct T *T;$/;"	t	typeref:struct:T
T	.\include\bit.h	24;"	d
T	.\include\bit.h	4;"	d
T	.\include\chan.h	/^typedef struct T *T;$/;"	t	typeref:struct:T
T	.\include\chan.h	4;"	d
T	.\include\chan.h	9;"	d
T	.\include\except.h	/^typedef struct T {$/;"	s
T	.\include\except.h	/^} T;$/;"	t	typeref:struct:T
T	.\include\except.h	5;"	d
T	.\include\except.h	91;"	d
T	.\include\fmt.h	/^typedef void (*T)(int code, va_list_box *box,$/;"	t
T	.\include\fmt.h	10;"	d
T	.\include\fmt.h	36;"	d
T	.\include\list.h	/^struct T {$/;"	s
T	.\include\list.h	/^typedef struct T *T;$/;"	t	typeref:struct:T
T	.\include\list.h	21;"	d
T	.\include\list.h	4;"	d
T	.\include\mp.h	/^typedef unsigned char *T;$/;"	t
T	.\include\mp.h	67;"	d
T	.\include\mp.h	8;"	d
T	.\include\ring.h	/^typedef struct T *T;$/;"	t	typeref:struct:T
T	.\include\ring.h	19;"	d
T	.\include\ring.h	4;"	d
T	.\include\sem.h	/^typedef struct T {$/;"	s
T	.\include\sem.h	/^} T;$/;"	t	typeref:struct:T
T	.\include\sem.h	16;"	d
T	.\include\sem.h	4;"	d
T	.\include\seq.h	/^typedef struct T *T;$/;"	t	typeref:struct:T
T	.\include\seq.h	16;"	d
T	.\include\seq.h	4;"	d
T	.\include\set.h	/^typedef struct T *T;$/;"	t	typeref:struct:T
T	.\include\set.h	21;"	d
T	.\include\set.h	4;"	d
T	.\include\stack.h	/^typedef struct T *T;$/;"	t	typeref:struct:T
T	.\include\stack.h	11;"	d
T	.\include\stack.h	4;"	d
T	.\include\str.h	41;"	d
T	.\include\table.h	/^typedef struct T *T;$/;"	t	typeref:struct:T
T	.\include\table.h	19;"	d
T	.\include\table.h	4;"	d
T	.\include\text.h	/^typedef struct T {$/;"	s
T	.\include\text.h	/^} T;$/;"	t	typeref:struct:T
T	.\include\text.h	44;"	d
T	.\include\text.h	6;"	d
T	.\include\thread.h	/^typedef struct T *T;$/;"	t	typeref:struct:T
T	.\include\thread.h	17;"	d
T	.\include\thread.h	5;"	d
T	.\include\xp.h	/^typedef unsigned char *T;$/;"	t
T	.\include\xp.h	28;"	d
T	.\include\xp.h	4;"	d
T	.\src\ap.c	/^struct T {$/;"	s	file:
T	.\src\ap.c	11;"	d	file:
T	.\src\arena.c	/^struct T {$/;"	s	file:
T	.\src\arena.c	7;"	d	file:
T	.\src\array.c	8;"	d	file:
T	.\src\bit.c	/^struct T {$/;"	s	file:
T	.\src\bit.c	7;"	d	file:
T	.\src\chan.c	/^struct T {$/;"	s	file:
T	.\src\chan.c	7;"	d	file:
T	.\src\except.c	6;"	d	file:
T	.\src\fmt.c	14;"	d	file:
T	.\src\list.c	7;"	d	file:
T	.\src\mp.c	12;"	d	file:
T	.\src\ring.c	/^struct T {$/;"	s	file:
T	.\src\ring.c	8;"	d	file:
T	.\src\seq.c	/^struct T {$/;"	s	file:
T	.\src\seq.c	10;"	d	file:
T	.\src\set.c	/^struct T {$/;"	s	file:
T	.\src\set.c	8;"	d	file:
T	.\src\stack.c	/^struct T {$/;"	s	file:
T	.\src\stack.c	6;"	d	file:
T	.\src\table.c	/^struct T {$/;"	s	file:
T	.\src\table.c	7;"	d	file:
T	.\src\text.c	8;"	d	file:
T	.\src\thread-nt.c	/^struct T {$/;"	s	file:
T	.\src\thread-nt.c	14;"	d	file:
T	.\src\thread-nt.c	265;"	d	file:
T	.\src\thread-nt.c	267;"	d	file:
T	.\src\thread-nt.c	313;"	d	file:
T	.\src\thread.c	/^struct T {$/;"	s	file:
T	.\src\thread.c	13;"	d	file:
T	.\src\thread.c	290;"	d	file:
T	.\src\thread.c	291;"	d	file:
T	.\src\thread.c	325;"	d	file:
T	.\src\xp.c	6;"	d	file:
TABLE_INCLUDED	.\include\table.h	3;"	d
TEXT_INCLUDED	.\include\text.h	3;"	d
THREAD_INCLUDED	.\include\thread.h	3;"	d
THRESHOLD	.\src\arena.c	12;"	d	file:
TRY	.\include\except.h	36;"	d
TRY	.\include\except.h	66;"	d
Table_free	.\src\table.c	/^void Table_free(T *table) {$/;"	f
Table_get	.\src\table.c	/^void *Table_get(T table, const void *key) {$/;"	f
Table_length	.\src\table.c	/^int Table_length(T table) {$/;"	f
Table_map	.\src\table.c	/^void Table_map(T table,$/;"	f
Table_new	.\src\table.c	/^T Table_new(int hint,$/;"	f
Table_put	.\src\table.c	/^void *Table_put(T table, const void *key, void *value) {$/;"	f
Table_remove	.\src\table.c	/^void *Table_remove(T table, const void *key) {$/;"	f
Table_toArray	.\src\table.c	/^void **Table_toArray(T table, void *end) {$/;"	f
Text_any	.\src\text.c	/^int Text_any(T s, int i, T set) {$/;"	f
Text_ascii	.\src\text.c	/^const T Text_ascii  = { 127, cset };$/;"	v
Text_box	.\src\text.c	/^T Text_box(const char *str, int len) {$/;"	f
Text_cat	.\src\text.c	/^T Text_cat(T s1, T s2) {$/;"	f
Text_chr	.\src\text.c	/^int Text_chr(T s, int i, int j, int c) {$/;"	f
Text_cmp	.\src\text.c	/^int Text_cmp(T s1, T s2) {$/;"	f
Text_cset	.\src\text.c	/^const T Text_cset   = { 256, cset };$/;"	v
Text_digits	.\src\text.c	/^const T Text_digits = {  10, cset + '0' };$/;"	v
Text_dup	.\src\text.c	/^T Text_dup(T s, int n) {$/;"	f
Text_find	.\src\text.c	/^int Text_find(T s, int i, int j, T str) {$/;"	f
Text_fmt	.\src\text.c	/^void Text_fmt(int code, va_list_box *box,$/;"	f
Text_get	.\src\text.c	/^char *Text_get(char *str, int size, T s) {$/;"	f
Text_lcase	.\src\text.c	/^const T Text_lcase  = {  26, cset + 'a' };$/;"	v
Text_many	.\src\text.c	/^int Text_many(T s, int i, int j, T set) {$/;"	f
Text_map	.\src\text.c	/^T Text_map(T s, const T *from, const T *to) {$/;"	f
Text_match	.\src\text.c	/^int Text_match(T s, int i, int j, T str) {$/;"	f
Text_null	.\src\text.c	/^const T Text_null   = {   0, cset };$/;"	v
Text_pos	.\src\text.c	/^int Text_pos(T s, int i) {$/;"	f
Text_put	.\src\text.c	/^T Text_put(const char *str) {$/;"	f
Text_rchr	.\src\text.c	/^int Text_rchr(T s, int i, int j, int c) {$/;"	f
Text_restore	.\src\text.c	/^void Text_restore(Text_save_T *save) {$/;"	f
Text_reverse	.\src\text.c	/^T Text_reverse(T s) {$/;"	f
Text_rfind	.\src\text.c	/^int Text_rfind(T s, int i, int j, T str) {$/;"	f
Text_rmany	.\src\text.c	/^int Text_rmany(T s, int i, int j, T set) {$/;"	f
Text_rmatch	.\src\text.c	/^int Text_rmatch(T s, int i, int j, T str) {$/;"	f
Text_rupto	.\src\text.c	/^int Text_rupto(T s, int i, int j, T set) {$/;"	f
Text_save	.\src\text.c	/^Text_save_T Text_save(void) {$/;"	f
Text_save_T	.\include\text.h	/^typedef struct Text_save_T *Text_save_T;$/;"	t	typeref:struct:Text_save_T
Text_save_T	.\src\text.c	/^struct Text_save_T {$/;"	s	file:
Text_sub	.\src\text.c	/^T Text_sub(T s, int i, int j) {$/;"	f
Text_ucase	.\src\text.c	/^const T Text_ucase  = {  26, cset + 'A' };$/;"	v
Text_upto	.\src\text.c	/^int Text_upto(T s, int i, int j, T set) {$/;"	f
Thread_Alerted	.\src\thread-nt.c	/^const Except_T Thread_Alerted = { "Thread alerted" };$/;"	v
Thread_Alerted	.\src\thread.c	/^const Except_T Thread_Alerted = { "Thread alerted" };$/;"	v
Thread_Failed	.\src\thread-nt.c	/^const Except_T Thread_Failed  = { "Thread creation failed" };$/;"	v
Thread_Failed	.\src\thread.c	/^const Except_T Thread_Failed =$/;"	v
Thread_alert	.\src\thread-nt.c	/^void Thread_alert(T t) {$/;"	f
Thread_alert	.\src\thread.c	/^void Thread_alert(T t) {$/;"	f
Thread_exit	.\src\thread-nt.c	/^void Thread_exit(int code) {$/;"	f
Thread_exit	.\src\thread.c	/^void Thread_exit(int code) {$/;"	f
Thread_init	.\src\thread-nt.c	/^int Thread_init(int preempt, ...) {$/;"	f
Thread_init	.\src\thread.c	/^int Thread_init(int preempt, ...) {$/;"	f
Thread_join	.\src\thread-nt.c	/^int Thread_join(T t) {$/;"	f
Thread_join	.\src\thread.c	/^int Thread_join(T t) {$/;"	f
Thread_new	.\src\thread-nt.c	/^T Thread_new(int apply(void *), void *args, int nbytes, ...) {$/;"	f
Thread_new	.\src\thread.c	/^T Thread_new(int apply(void *), void *args,$/;"	f
Thread_pause	.\src\thread-nt.c	/^void Thread_pause(void) {$/;"	f
Thread_pause	.\src\thread.c	/^void Thread_pause(void) {$/;"	f
Thread_self	.\src\thread-nt.c	/^T Thread_self(void) {$/;"	f
Thread_self	.\src\thread.c	/^T Thread_self(void) {$/;"	f
Unsupported	.\src\swtch.s	/^Unsupported platform$/;"	l
XP_INCLUDED	.\include\xp.h	3;"	d
XP_add	.\src\xp.c	/^int XP_add(int n, T z, T x, T y, int carry) {$/;"	f
XP_cmp	.\src\xp.c	/^int XP_cmp(int n, T x, T y) {$/;"	f
XP_diff	.\src\xp.c	/^int XP_diff(int n, T z, T x, int y) {$/;"	f
XP_div	.\src\xp.c	/^int XP_div(int n, T q, T x, int m, T y, T r, T tmp) {$/;"	f
XP_fromint	.\src\xp.c	/^unsigned long XP_fromint(int n, T z, unsigned long u) {$/;"	f
XP_fromstr	.\src\xp.c	/^int XP_fromstr(int n, T z, const char *str,$/;"	f
XP_length	.\src\xp.c	/^int XP_length(int n, T x) {$/;"	f
XP_lshift	.\src\xp.c	/^void XP_lshift(int n, T z, int m, T x, int s, int fill) {$/;"	f
XP_mul	.\src\xp.c	/^int XP_mul(T z, int n, T x, int m, T y) {$/;"	f
XP_neg	.\src\xp.c	/^int XP_neg(int n, T z, T x, int carry) {$/;"	f
XP_product	.\src\xp.c	/^int XP_product(int n, T z, T x, int y) {$/;"	f
XP_quotient	.\src\xp.c	/^int XP_quotient(int n, T z, T x, int y) {$/;"	f
XP_rshift	.\src\xp.c	/^void XP_rshift(int n, T z, int m, T x, int s, int fill) {$/;"	f
XP_sub	.\src\xp.c	/^int XP_sub(int n, T z, T x, T y, int borrow) {$/;"	f
XP_sum	.\src\xp.c	/^int XP_sum(int n, T z, T x, int y) {$/;"	f
XP_toint	.\src\xp.c	/^unsigned long XP_toint(int n, T x) {$/;"	f
XP_tostr	.\src\xp.c	/^char *XP_tostr(char *str, int size, int base,$/;"	f
_ENDMONITOR	.\src\swtch.s	/^_ENDMONITOR:$/;"	l
_MONITOR	.\src\thread.c	/^void _MONITOR(void) {}$/;"	f
__ENDMONITOR	.\src\swtch.s	/^	__ENDMONITOR:$/;"	l
__ENDMONITOR	.\src\swtch.s	/^__ENDMONITOR:$/;"	l
__start	.\src\swtch.s	/^	__start:	ld	[%sp+64+4],%o0$/;"	l
__swtch	.\src\swtch.s	/^	__swtch:	save	%sp,-(8+64),%sp$/;"	l
__swtch	.\src\swtch.s	/^__swtch:$/;"	l
__thrstart	.\src\swtch.s	/^__thrstart:$/;"	l
_start	.\src\swtch.s	/^_start:	.frame	$sp,0,$26$/;"	l
_start	.\src\swtch.s	/^_start:	move	$4,$23	# register 23 holds args$/;"	l
_swtch	.\src\swtch.s	/^_swtch:	.frame	$sp,88,$31$/;"	l
_swtch	.\src\swtch.s	/^_swtch:	lda	$sp,-112($sp)	# allocate _swtch's frame$/;"	l
_swtch	.\src\swtch.s	/^_swtch:$/;"	l
_thrstart	.\src\swtch.s	/^_thrstart:$/;"	l
a	.\examples\sort.c	/^	int *a;$/;"	m	struct:args	file:
a	.\src\arena.c	/^	union align a;$/;"	m	union:header	typeref:union:header::align	file:
add	.\examples\mpcalc.c	/^	MP_T (*add)(MP_T, MP_T, MP_T);$/;"	m	struct:__anon1	file:
add	.\src\ap.c	/^static T add(T z, T x, T y) {$/;"	f	file:
addThread	.\src\thread-nt.c	/^static void addThread(T t) {$/;"	f	file:
alerted	.\src\thread-nt.c	/^	int alerted;		\/* 1 if this thread has been alerted *\/$/;"	m	struct:T	file:
alerted	.\src\thread.c	/^	int alerted;$/;"	m	struct:T	file:
align	.\misc\maxalign.c	/^union align {$/;"	u	file:
align	.\src\arena.c	/^union align {$/;"	u	file:
align	.\src\memchk.c	/^union align {$/;"	u	file:
alloc	.\src\text.c	/^static char *alloc(int len) {$/;"	f	file:
allthreads	.\src\thread-nt.c	/^static T allthreads[317];$/;"	v	file:
ap	.\include\fmt.h	/^	va_list ap;$/;"	m	struct:va_list_box
append	.\src\fmt.c	/^static int append(int c, void *cl) {$/;"	f	file:
apply	.\src\thread-nt.c	/^	int (*apply)(void *);	\/* initial function for this thread *\/$/;"	m	struct:T	file:
args	.\examples\sieve.c	/^struct args {$/;"	s	file:
args	.\examples\sort.c	/^struct args {$/;"	s	file:
args	.\examples\spin.c	/^struct args {$/;"	s	file:
args	.\src\thread-nt.c	/^	void *args;		\/* argument for apply *\/$/;"	m	struct:T	file:
array	.\include\arrayrep.h	/^	char *array;$/;"	m	struct:T
array	.\src\seq.c	/^	struct Array_T array;$/;"	m	struct:T	typeref:struct:T::Array_T	file:
assert	.\include\assert.h	2;"	d
assert	.\include\assert.h	4;"	d
assert	.\include\assert.h	8;"	d
assert	.\src\assert.c	/^void (assert)(int e) {$/;"	f
assert	.\src\except.c	44;"	d	file:
assert	.\src\except.c	45;"	d	file:
atom	.\src\atom.c	/^static struct atom {$/;"	s	file:
avail	.\src\arena.c	/^	char *avail;$/;"	m	struct:T	file:
avail	.\src\text.c	/^	char *avail;$/;"	m	struct:Text_save_T	file:
avail	.\src\text.c	/^	char *avail;$/;"	m	struct:chunk	file:
b	.\src\arena.c	/^	struct T b;$/;"	m	union:header	typeref:struct:header::T	file:
basename	.\examples\basename.c	/^char *basename(char *path, int i, int j, const char *suffix) {$/;"	f
binding	.\src\table.c	/^	struct binding {$/;"	s	struct:T	file:
bitop	.\src\mp.c	17;"	d	file:
bitopi	.\src\mp.c	21;"	d	file:
bp	.\src\fmt.c	/^	char *bp;$/;"	m	struct:buf	file:
buckets	.\src\atom.c	/^} *buckets[2048];$/;"	v	typeref:struct:atom	file:
buckets	.\src\set.c	/^	} **buckets;$/;"	m	struct:T	typeref:struct:T::member	file:
buckets	.\src\table.c	/^	} **buckets;$/;"	m	struct:T	typeref:struct:T::binding	file:
buf	.\src\fmt.c	/^	char *buf;$/;"	m	struct:buf	file:
buf	.\src\fmt.c	/^struct buf {$/;"	s	file:
bytes	.\src\bit.c	/^	unsigned char *bytes;$/;"	m	struct:T	file:
c	.\examples\sieve.c	/^	Chan_T c;$/;"	m	struct:args	file:
chunk	.\src\text.c	/^static struct chunk {$/;"	s	file:
cmp	.\src\ap.c	/^static int cmp(T x, T y) {$/;"	f	file:
cmp	.\src\set.c	/^	int (*cmp)(const void *x, const void *y);$/;"	m	struct:T	file:
cmp	.\src\table.c	/^	int (*cmp)(const void *x, const void *y);$/;"	m	struct:T	file:
cmpatom	.\src\set.c	/^static int cmpatom(const void *x, const void *y) {$/;"	f	file:
cmpatom	.\src\table.c	/^static int cmpatom(const void *x, const void *y) {$/;"	f	file:
cmpint	.\examples\xref.c	/^int cmpint(const void *x, const void *y) {$/;"	f
code	.\src\thread-nt.c	/^	int code;		\/* exit code *\/$/;"	m	struct:T	file:
code	.\src\thread.c	/^	int code;$/;"	m	struct:T	file:
compare	.\examples\cref.c	/^int compare(const void *x, const void *y) {$/;"	f
compare	.\examples\iref.c	/^int compare(const void *x, const void *y) {$/;"	f
compare	.\examples\kref.c	/^int compare(const void *x, const void *y) {$/;"	f
compare	.\examples\wf.c	/^int compare(const void *x, const void *y) {$/;"	f
compare	.\examples\xref.c	/^int compare(const void *x, const void *y) {$/;"	f
convert	.\src\str.c	9;"	d	file:
copy	.\examples\cref.c	/^Text_T *copy(Text_T t) {$/;"	f
copy	.\examples\iref.c	/^Text_T *copy(Text_T t) {$/;"	f
copy	.\src\bit.c	/^static T copy(T t) {$/;"	f	file:
copy	.\src\set.c	/^static T copy(T t, int hint) {$/;"	f	file:
count	.\include\sem.h	/^	int count;$/;"	m	struct:T
count	.\src\stack.c	/^	int count;$/;"	m	struct:T	file:
cref	.\examples\cref.c	/^void cref(char *name, FILE *fp, Table_T identifiers) {$/;"	f
critical	.\src\thread-nt.c	/^static int critical;$/;"	v	file:
critical	.\src\thread.c	/^static int critical;$/;"	v	file:
csection	.\src\thread-nt.c	/^static CRITICAL_SECTION csection;$/;"	v	file:
cset	.\src\text.c	/^static char cset[] =$/;"	v	file:
current	.\src\text.c	/^	struct chunk *current;$/;"	m	struct:Text_save_T	typeref:struct:Text_save_T::chunk	file:
current	.\src\text.c	/^} head = { NULL, NULL, NULL }, *current = &head;$/;"	v	typeref:struct:chunk	file:
current	.\src\thread.c	/^static T current;$/;"	v	file:
cutoff	.\examples\sort.c	/^int cutoff = 10000;$/;"	v
cvt	.\src\fmt.c	/^static T cvt[256] = {$/;"	v	file:
cvt_c	.\src\fmt.c	/^static void cvt_c(int code, va_list_box *box,$/;"	f	file:
cvt_d	.\src\fmt.c	/^static void cvt_d(int code, va_list_box *box,$/;"	f	file:
cvt_f	.\src\fmt.c	/^static void cvt_f(int code, va_list_box *box,$/;"	f	file:
cvt_o	.\src\fmt.c	/^static void cvt_o(int code, va_list_box *box,$/;"	f	file:
cvt_p	.\src\fmt.c	/^static void cvt_p(int code, va_list_box *box,$/;"	f	file:
cvt_s	.\src\fmt.c	/^static void cvt_s(int code, va_list_box *box,$/;"	f	file:
cvt_u	.\src\fmt.c	/^static void cvt_u(int code, va_list_box *box,$/;"	f	file:
cvt_x	.\src\fmt.c	/^static void cvt_x(int code, va_list_box *box,$/;"	f	file:
d	.\misc\maxalign.c	/^	double d;$/;"	m	union:align	file:
dalloc	.\src\memchk.c	/^static struct descriptor *dalloc(void *ptr, long size,$/;"	f	file:
delete	.\src\thread.c	/^static void delete(T t, T *q) {$/;"	f	file:
descriptor	.\src\memchk.c	/^static struct descriptor {$/;"	s	file:
digits	.\src\ap.c	/^	XP_T digits;$/;"	m	struct:T	file:
dirname	.\examples\basename.c	/^char *dirname(char *path, int i, int j) {$/;"	f
div	.\examples\mpcalc.c	/^	MP_T (*div)(MP_T, MP_T, MP_T);$/;"	m	struct:__anon1	file:
doubleword	.\examples\double.c	/^void doubleword(char *name, FILE *fp) {$/;"	f
elem	.\src\stack.c	/^	struct elem {$/;"	s	struct:T	file:
env	.\include\except.h	/^	jmp_buf env;$/;"	m	struct:Except_Frame
equal	.\src\text.c	12;"	d	file:
estack	.\src\thread.c	/^	Except_Frame *estack;$/;"	m	struct:T	file:
exception	.\include\except.h	/^	const T *exception;$/;"	m	struct:Except_Frame
expand	.\src\seq.c	/^static void expand(T seq) {$/;"	f	file:
f	.\examples\mpcalc.c	/^ *f = &s;$/;"	v	typeref:struct:__anon1
f	.\misc\maxalign.c	/^	float f;$/;"	m	union:align	file:
file	.\include\except.h	/^	const char *file;$/;"	m	struct:Except_Frame
file	.\src\memchk.c	/^	const char *file;$/;"	m	struct:descriptor	file:
filter	.\examples\sieve.c	/^void filter(int primes[], Chan_T input, Chan_T output) {$/;"	f
find	.\src\memchk.c	/^static struct descriptor *find(const void *ptr) {$/;"	f	file:
first	.\examples\cref.c	/^Text_T first, rest;$/;"	v
first	.\examples\iref.c	/^Text_T first, rest;$/;"	v
first	.\examples\kref.c	/^char *first, *rest;$/;"	v
first	.\examples\wf.c	/^int first(int c) {$/;"	f
first	.\examples\xref.c	/^int first(int c) {$/;"	f
first	.\include\list.h	/^	void *first;$/;"	m	struct:T
fmt	.\examples\mpcalc.c	/^	const char *fmt;$/;"	m	struct:__anon1	file:
fp	.\misc\maxalign.c	/^	void (*fp)(void);$/;"	m	union:align	file:
free	.\src\memchk.c	/^	struct descriptor *free;$/;"	m	struct:descriptor	typeref:struct:descriptor::descriptor	file:
freechunks	.\src\arena.c	/^static T freechunks;$/;"	v	file:
freelist	.\src\memchk.c	/^static struct descriptor freelist = { &freelist };$/;"	v	typeref:struct:descriptor	file:
freelist	.\src\thread.c	/^static T freelist;$/;"	v	file:
functp	.\misc\maxalign.c	/^typedef void (*functp);$/;"	t	file:
get	.\src\thread.c	/^static T get(T *q) {$/;"	f	file:
getThreadByID	.\src\thread-nt.c	/^static T getThreadByID(DWORD id) {$/;"	f	file:
getword	.\examples\cref.c	/^Text_T getword(Text_T *line, Text_T first, Text_T rest) {$/;"	f
getword	.\examples\double.c	/^int getword(FILE *fp, char *buf, int size) {$/;"	f
getword	.\examples\getword.c	/^int getword(FILE *fp, char *buf, int size,$/;"	f
getword	.\examples\iref.c	/^Text_T getword(Text_T *line, Text_T first, Text_T rest) {$/;"	f
getword	.\examples\kref.c	/^int getword(char *line, int *i, char *first, char *rest) {$/;"	f
handle	.\src\thread-nt.c	/^	T handle;		\/* self pointer *\/$/;"	m	struct:T	file:
handle	.\src\thread.c	/^	T handle;$/;"	m	struct:T	file:
hash	.\src\memchk.c	21;"	d	file:
hash	.\src\set.c	/^	unsigned (*hash)(const void *x);$/;"	m	struct:T	file:
hash	.\src\table.c	/^	unsigned (*hash)(const void *key);$/;"	m	struct:T	file:
hashatom	.\src\set.c	/^static unsigned hashatom(const void *x) {$/;"	f	file:
hashatom	.\src\table.c	/^static unsigned hashatom(const void *key) {$/;"	f	file:
head	.\src\ring.c	/^	} *head;$/;"	m	struct:T	typeref:struct:T::node	file:
head	.\src\seq.c	/^	int head;$/;"	m	struct:T	file:
head	.\src\stack.c	/^	} *head;$/;"	m	struct:T	typeref:struct:T::elem	file:
head	.\src\text.c	/^} head = { NULL, NULL, NULL }, *current = &head;$/;"	v	typeref:struct:chunk	file:
header	.\src\arena.c	/^union header {$/;"	u	file:
htab	.\src\memchk.c	/^} *htab[2048];$/;"	v	typeref:struct:descriptor	file:
i	.\misc\maxalign.c	/^	int i;$/;"	m	union:align	file:
ibase	.\examples\mpcalc.c	/^int ibase = 10;$/;"	v
idx	.\src\str.c	8;"	d	file:
idx	.\src\text.c	9;"	d	file:
inqueue	.\src\thread.c	/^	T *inqueue;$/;"	m	struct:T	file:
insert	.\src\fmt.c	/^static int insert(int c, void *cl) {$/;"	f	file:
intcmp	.\examples\xref.c	/^int intcmp(const void *x, const void *y) {$/;"	f
interrupt	.\src\thread.c	/^static int interrupt(int sig, int code,$/;"	f	file:
interrupt	.\src\thread.c	/^static int interrupt(int sig, struct sigcontext sc) {$/;"	f	file:
inthash	.\examples\xref.c	/^unsigned inthash(const void *x) {$/;"	f
ip	.\examples\spin.c	/^	int *ip;$/;"	m	struct:args	file:
iref	.\examples\iref.c	/^void iref(char *name, FILE *fp, Table_T identifiers) {$/;"	f
isatend	.\src\text.c	10;"	d	file:
isempty	.\src\thread.c	14;"	d	file:
isone	.\src\ap.c	21;"	d	file:
iszero	.\src\ap.c	18;"	d	file:
iszero	.\src\mp.c	15;"	d	file:
join	.\src\thread-nt.c	/^	HANDLE join;		\/* join semaphore *\/$/;"	m	struct:T	file:
join	.\src\thread.c	/^	T join;$/;"	m	struct:T	file:
join0	.\src\thread-nt.c	/^static HANDLE join0;		\/* Thread_join(NULL) semaphore *\/$/;"	v	file:
join0	.\src\thread.c	/^static T join0;$/;"	v	file:
join0count	.\src\thread-nt.c	/^static int join0count;		\/* number of threads waiting on join0; always 0 or 1 *\/$/;"	v	file:
joinlist	.\src\thread-nt.c	/^	T joinlist;		\/* threads waiting on join *\/$/;"	m	struct:T	file:
key	.\src\table.c	/^		const void *key;$/;"	m	struct:T::binding	file:
kref	.\examples\kref.c	/^void kref(char *name, FILE *fp, Table_T identifiers) {$/;"	f
l	.\misc\maxalign.c	/^	long l;$/;"	m	union:align	file:
last	.\examples\sieve.c	/^	int n, last;$/;"	m	struct:args	file:
lb	.\examples\sort.c	/^	int lb, ub;$/;"	m	struct:args	file:
ld	.\misc\maxalign.c	/^	long double ld;$/;"	m	union:align	file:
len	.\include\text.h	/^	int len;$/;"	m	struct:T
len	.\src\atom.c	/^	int len;$/;"	m	struct:atom	file:
length	.\include\arrayrep.h	/^	int length;$/;"	m	struct:T
length	.\src\bit.c	/^	int length;$/;"	m	struct:T	file:
length	.\src\ring.c	/^	int length;$/;"	m	struct:T	file:
length	.\src\seq.c	/^	int length;$/;"	m	struct:T	file:
length	.\src\set.c	/^	int length;$/;"	m	struct:T	file:
length	.\src\table.c	/^	int length;$/;"	m	struct:T	file:
limit	.\src\arena.c	/^	char *limit;$/;"	m	struct:T	file:
limit	.\src\text.c	/^	char *limit;$/;"	m	struct:chunk	file:
line	.\include\except.h	/^	int line;$/;"	m	struct:Except_Frame
line	.\src\memchk.c	/^	int line;$/;"	m	struct:descriptor	file:
linenum	.\examples\double.c	/^int linenum;$/;"	v
linenum	.\examples\xref.c	/^int linenum;$/;"	v
link	.\src\atom.c	/^	struct atom *link;$/;"	m	struct:atom	typeref:struct:atom::atom	file:
link	.\src\memchk.c	/^	struct descriptor *link;$/;"	m	struct:descriptor	typeref:struct:descriptor::descriptor	file:
link	.\src\set.c	/^		struct member *link;$/;"	m	struct:T::member	typeref:struct:T::member::member	file:
link	.\src\stack.c	/^		struct elem *link;$/;"	m	struct:T::elem	typeref:struct:T::elem::elem	file:
link	.\src\table.c	/^		struct binding *link;$/;"	m	struct:T::binding	typeref:struct:T::binding::binding	file:
link	.\src\text.c	/^	struct chunk *link;$/;"	m	struct:chunk	typeref:struct:chunk::chunk	file:
link	.\src\thread-nt.c	/^	T link;			\/* next thread on this join list *\/$/;"	m	struct:T	file:
link	.\src\thread.c	/^	T link;$/;"	m	struct:T	file:
llink	.\src\ring.c	/^		struct node *llink, *rlink;$/;"	m	struct:T::node	typeref:struct:T::node::node	file:
lp	.\misc\maxalign.c	/^	long *lp;$/;"	m	union:align	file:
lsbmask	.\src\bit.c	/^unsigned char lsbmask[] = {$/;"	v
main	.\examples\basename.c	/^int main(int argc, char *argv[]) {$/;"	f
main	.\examples\calc.c	/^int main(int argc, char *argv[]) {$/;"	f
main	.\examples\cref.c	/^int main(int argc, char *argv[]) {$/;"	f
main	.\examples\double.c	/^int main(int argc, char *argv[]) {$/;"	f
main	.\examples\idents.c	/^int main(int argc, char *argv[]) {$/;"	f
main	.\examples\ids.c	/^int main(int argc, char *argv[]) {$/;"	f
main	.\examples\iref.c	/^int main(int argc, char *argv[]) {$/;"	f
main	.\examples\kref.c	/^int main(int argc, char *argv[]) {$/;"	f
main	.\examples\mpcalc.c	/^int main(int argc, char *argv[]) {$/;"	f
main	.\examples\sieve.c	/^int main(int argc, char *argv[]) {$/;"	f
main	.\examples\sort.c	/^main(int argc, char *argv[]) {$/;"	f
main	.\examples\spin.c	/^int main(int argc, char *argv[]) {$/;"	f
main	.\examples\wf.c	/^int main(int argc, char *argv[]) {$/;"	f
main	.\examples\words.c	/^int main(int argc, char *argv[]) {$/;"	f
main	.\examples\xref.c	/^int main(int argc, char *argv[]) {$/;"	f
main	.\misc\maxalign.c	/^int main(int argc, char *argv[]) {$/;"	f
map	.\src\xp.c	/^static char map[] = {$/;"	v	file:
maxdigits	.\src\ap.c	19;"	d	file:
member	.\src\set.c	/^		const void *member;$/;"	m	struct:T::member	file:
member	.\src\set.c	/^	struct member {$/;"	s	struct:T	file:
memcmp	.\src\memcmp.c	/^int memcmp(const void *s1, const void *s2, size_t n) {$/;"	f
memmove	.\src\memmove.c	/^void *memmove(void *s1, const void *s2, size_t n) {$/;"	f
mk	.\src\ap.c	/^static T mk(int size) {$/;"	f	file:
mod	.\examples\mpcalc.c	/^	MP_T (*mod)(MP_T, MP_T, MP_T);$/;"	m	struct:__anon1	file:
msb	.\src\mp.c	/^static unsigned char msb = 0xFF;$/;"	v	file:
msbmask	.\src\bit.c	/^unsigned char msbmask[] = {$/;"	v
mul	.\examples\mpcalc.c	/^	MP_T (*mul)(MP_T, MP_T, MP_T);$/;"	m	struct:__anon1	file:
mulmod	.\src\ap.c	/^static T mulmod(T x, T y, T p) {$/;"	f	file:
mutex	.\examples\spin.c	/^	Sem_T *mutex;$/;"	m	struct:args	file:
n	.\examples\sieve.c	/^	int n, last;$/;"	m	struct:args	file:
n	.\examples\spin.c	/^int n;$/;"	v
nbits	.\src\mp.c	/^static int nbits  =  32;$/;"	v	file:
nbytes	.\src\bit.c	15;"	d	file:
nbytes	.\src\mp.c	/^static int nbytes = (32-1)\/8 + 1;$/;"	v	file:
ndigits	.\src\ap.c	/^	int ndigits;$/;"	m	struct:T	file:
next	.\src\thread-nt.c	/^	T next;			\/* next thread on this hash chain *\/$/;"	m	struct:T	file:
next	.\src\thread.c	/^	T next;$/;"	m	struct:T	file:
nfree	.\src\arena.c	/^static int nfree;$/;"	v	file:
node	.\src\ring.c	/^	struct node {$/;"	s	struct:T	file:
normalize	.\src\ap.c	/^static T normalize(T z, int n) {$/;"	f	file:
nthreads	.\src\thread-nt.c	/^static int nthreads;		\/* number of threads in allthreads *\/$/;"	v	file:
nthreads	.\src\thread.c	/^static int nthreads;$/;"	v	file:
nwords	.\src\bit.c	14;"	d	file:
obase	.\examples\mpcalc.c	/^int obase = 10;$/;"	v
ones	.\src\mp.c	14;"	d	file:
outc	.\src\fmt.c	/^static int outc(int c, void *cl) {$/;"	f	file:
outs	.\examples\sort.c	/^static void outs(const char *fmt, ...) {$/;"	f	file:
p	.\misc\maxalign.c	/^	void *p;$/;"	m	union:align	file:
pad	.\src\arena.c	/^	char pad[MAXALIGN];$/;"	m	union:align	file:
pad	.\src\fmt.c	20;"	d	file:
pad	.\src\memchk.c	/^	char pad[MAXALIGN];$/;"	m	union:align	file:
partition	.\examples\sort.c	/^int partition(int a[], int i, int j) {$/;"	f
pop	.\examples\calc.c	/^AP_T pop(void) {$/;"	f
pop	.\examples\mpcalc.c	/^MP_T pop(void) {$/;"	f
prev	.\include\except.h	/^	Except_Frame *prev;$/;"	m	struct:Except_Frame
prev	.\src\arena.c	/^	T prev;$/;"	m	struct:T	file:
print	.\examples\cref.c	/^void print(Table_T files) {$/;"	f
print	.\examples\iref.c	/^void print(Table_T files) {$/;"	f
print	.\examples\kref.c	/^void print(Table_T files) {$/;"	f
print	.\examples\xref.c	/^void print(Table_T files) {$/;"	f
ptr	.\src\chan.c	/^	const void *ptr;$/;"	m	struct:T	file:
ptr	.\src\memchk.c	/^	const void *ptr;$/;"	m	struct:descriptor	file:
put	.\src\thread.c	/^static void put(T t, T *q) {$/;"	f	file:
queue	.\include\sem.h	/^	void *queue;$/;"	m	struct:T
quick	.\examples\sort.c	/^int quick(void *cl) {$/;"	f
rcsid	.\examples\calc.c	/^static char rcsid[] = "$Id: calc.c 6 2007-01-22 00:45:22Z drhanson $";$/;"	v	file:
rcsid	.\examples\cref.c	/^static char rcsid[] = "$Id: cref.c 6 2007-01-22 00:45:22Z drhanson $";$/;"	v	file:
rcsid	.\examples\double.c	/^static char rcsid[] = "$Id: double.c 6 2007-01-22 00:45:22Z drhanson $";$/;"	v	file:
rcsid	.\examples\getword.c	/^static char rcsid[] = "$Id: getword.c 6 2007-01-22 00:45:22Z drhanson $";$/;"	v	file:
rcsid	.\examples\ids.c	/^static char rcsid[] = "$Id: ids.c 6 2007-01-22 00:45:22Z drhanson $";$/;"	v	file:
rcsid	.\examples\iref.c	/^static char rcsid[] = "$Id: iref.c 6 2007-01-22 00:45:22Z drhanson $";$/;"	v	file:
rcsid	.\examples\kref.c	/^static char rcsid[] = "$Id: kref.c 6 2007-01-22 00:45:22Z drhanson $";$/;"	v	file:
rcsid	.\examples\mpcalc.c	/^static const char *rcsid = "$Id: mpcalc.c 6 2007-01-22 00:45:22Z drhanson $";$/;"	v	file:
rcsid	.\examples\sieve.c	/^static const char *rcsid = "$Id: sieve.c 6 2007-01-22 00:45:22Z drhanson $" "\\n$Id: sieve.c 6 2007-01-22 00:45:22Z drhanson $";$/;"	v	file:
rcsid	.\examples\sort.c	/^static char rcsid[] = "$Id: sort.c 197 2008-09-27 21:59:31Z drhanson $" "\\n$Id: sort.c 197 2008-09-27 21:59:31Z drhanson $";$/;"	v	file:
rcsid	.\examples\spin.c	/^static char rcsid[] = "$Id: spin.c 6 2007-01-22 00:45:22Z drhanson $";$/;"	v	file:
rcsid	.\examples\wf.c	/^static char rcsid[] = "$Id: wf.c 6 2007-01-22 00:45:22Z drhanson $";$/;"	v	file:
rcsid	.\examples\xref.c	/^static char rcsid[] = "$Id: xref.c 6 2007-01-22 00:45:22Z drhanson $";$/;"	v	file:
rcsid	.\src\ap.c	/^static const char *rcsid = "$Id: ap.c 197 2008-09-27 21:59:31Z drhanson $";$/;"	v	file:
rcsid	.\src\arena.c	/^static char rcsid[] = "$Id: arena.c 6 2007-01-22 00:45:22Z drhanson $";$/;"	v	file:
rcsid	.\src\array.c	/^static const char *rcsid = "$Id: array.c 6 2007-01-22 00:45:22Z drhanson $";$/;"	v	file:
rcsid	.\src\assert.c	/^static char rcsid[] = "$Id: assert.c 6 2007-01-22 00:45:22Z drhanson $";$/;"	v	file:
rcsid	.\src\atom.c	/^static char rcsid[] = "$Id: atom.c 6 2007-01-22 00:45:22Z drhanson $";$/;"	v	file:
rcsid	.\src\bit.c	/^static char rcsid[] = "$Id: bit.c 6 2007-01-22 00:45:22Z drhanson $";$/;"	v	file:
rcsid	.\src\chan.c	/^static char rcsid[] = "$Id: chan.c 6 2007-01-22 00:45:22Z drhanson $";$/;"	v	file:
rcsid	.\src\except.c	/^static char rcsid[] = "$Id: except.c 6 2007-01-22 00:45:22Z drhanson $" "\\n$Id: except.c 6 2007-01-22 00:45:22Z drhanson $";$/;"	v	file:
rcsid	.\src\fmt.c	/^static char rcsid[] = "$Id: fmt.c 197 2008-09-27 21:59:31Z drhanson $";$/;"	v	file:
rcsid	.\src\list.c	/^static char rcsid[] = "$Id: list.c 6 2007-01-22 00:45:22Z drhanson $";$/;"	v	file:
rcsid	.\src\mem.c	/^static char rcsid[] = "$Id: mem.c 6 2007-01-22 00:45:22Z drhanson $";$/;"	v	file:
rcsid	.\src\memchk.c	/^static char rcsid[] = "$Id: memchk.c 6 2007-01-22 00:45:22Z drhanson $";$/;"	v	file:
rcsid	.\src\mp.c	/^static char rcsid[] = "$Id: mp.c 197 2008-09-27 21:59:31Z drhanson $";$/;"	v	file:
rcsid	.\src\ring.c	/^static char rcsid[] = "$Id: ring.c 6 2007-01-22 00:45:22Z drhanson $";$/;"	v	file:
rcsid	.\src\seq.c	/^static char rcsid[] = "$Id: seq.c 6 2007-01-22 00:45:22Z drhanson $";$/;"	v	file:
rcsid	.\src\set.c	/^static char rcsid[] = "$Id: set.c 6 2007-01-22 00:45:22Z drhanson $";$/;"	v	file:
rcsid	.\src\stack.c	/^static char rcsid[] = "$Id: stack.c 6 2007-01-22 00:45:22Z drhanson $";$/;"	v	file:
rcsid	.\src\str.c	/^static char rcsid[] = "$Id: str.c 197 2008-09-27 21:59:31Z drhanson $";$/;"	v	file:
rcsid	.\src\table.c	/^static char rcsid[] = "$Id: table.c 6 2007-01-22 00:45:22Z drhanson $";$/;"	v	file:
rcsid	.\src\text.c	/^static const char *rcsid = "$Id: text.c 197 2008-09-27 21:59:31Z drhanson $";$/;"	v	file:
rcsid	.\src\thread-nt.c	/^static char rcsid[] = "$Id: thread-nt.c 6 2007-01-22 00:45:22Z drhanson $";$/;"	v	file:
rcsid	.\src\thread.c	/^static char rcsid[] = "$Id: thread.c 183 2007-06-14 13:39:57Z drhanson $";$/;"	v	file:
rcsid	.\src\xp.c	/^static char rcsid[] = "$Id: xp.c 6 2007-01-22 00:45:22Z drhanson $";$/;"	v	file:
ready	.\src\thread.c	/^static T ready = NULL;$/;"	v	file:
reason	.\include\except.h	/^	const char *reason;$/;"	m	struct:T
recv	.\src\chan.c	/^	Sem_T send, recv, sync;$/;"	m	struct:T	file:
release	.\src\thread.c	/^static void release(void) {$/;"	f	file:
removeThread	.\src\thread-nt.c	/^static void removeThread(T t) {$/;"	f	file:
rest	.\examples\cref.c	/^Text_T first, rest;$/;"	v
rest	.\examples\iref.c	/^Text_T first, rest;$/;"	v
rest	.\examples\kref.c	/^char *first, *rest;$/;"	v
rest	.\examples\wf.c	/^int rest(int c) {$/;"	f
rest	.\examples\xref.c	/^int rest(int c) {$/;"	f
rest	.\include\list.h	/^	T rest;$/;"	m	struct:T
rlink	.\src\ring.c	/^		struct node *llink, *rlink;$/;"	m	struct:T::node	typeref:struct:T::node::	file:
root	.\src\thread-nt.c	/^static T root;$/;"	v	file:
root	.\src\thread.c	/^static struct Thread_T root;$/;"	v	typeref:struct:Thread_T	file:
run	.\src\thread.c	/^static void run(void) {$/;"	f	file:
s	.\examples\mpcalc.c	/^} s = { "%D\\n",$/;"	v	typeref:struct:__anon1
safe	.\examples\spin.c	/^int safe(void *cl) {$/;"	f
sc_pc	.\src\thread.c	115;"	d	file:
scatter	.\src\atom.c	/^static unsigned long scatter[] = {$/;"	v	file:
send	.\src\chan.c	/^	Sem_T send, recv, sync;$/;"	m	struct:T	file:
set	.\src\ap.c	/^static T set(T z, long int n) {$/;"	f	file:
setop	.\src\bit.c	16;"	d	file:
shft	.\src\mp.c	24;"	d	file:
shift	.\src\mp.c	/^static int shift  = (32-1)%8;$/;"	v	file:
sign	.\src\ap.c	/^	int sign;$/;"	m	struct:T	file:
sign	.\src\mp.c	13;"	d	file:
sink	.\examples\sieve.c	/^int sink(void *cl) {$/;"	f
size	.\include\arrayrep.h	/^	int size;$/;"	m	struct:T
size	.\src\ap.c	/^	int size;$/;"	m	struct:T	file:
size	.\src\chan.c	/^	int *size;$/;"	m	struct:T	file:
size	.\src\fmt.c	/^	int size;$/;"	m	struct:buf	file:
size	.\src\memchk.c	/^	long size;$/;"	m	struct:descriptor	file:
size	.\src\set.c	/^	int size;$/;"	m	struct:T	file:
size	.\src\table.c	/^	int size;$/;"	m	struct:T	file:
sort	.\examples\sort.c	/^void sort(int *x, int n, int argc, char *argv[]) {$/;"	f
source	.\examples\sieve.c	/^int source(void *cl) {$/;"	f
sp	.\examples\calc.c	/^Stack_T sp;$/;"	v
sp	.\examples\mpcalc.c	/^Seq_T sp;$/;"	v
sp	.\src\thread.c	/^	unsigned long *sp;						\/* must be first *\/$/;"	m	struct:T	file:
start	.\src\thread-nt.c	/^static unsigned __stdcall start(void *p) {$/;"	f	file:
str	.\include\text.h	/^	const char *str;$/;"	m	struct:T
str	.\src\atom.c	/^	char *str;$/;"	m	struct:atom	file:
strerror	.\src\strerror.c	/^char *strerror(int errnum) {$/;"	f
strhash	.\examples\kref.c	/^unsigned strhash(const void *x) {$/;"	f
strncmp	.\src\strncmp.c	/^int strncmp(const char *s1, const char *s2, size_t n) {$/;"	f
sub	.\examples\mpcalc.c	/^	MP_T (*sub)(MP_T, MP_T, MP_T);$/;"	m	struct:__anon1	file:
sub	.\src\ap.c	/^static T sub(T z, T x, T y) {$/;"	f	file:
sync	.\src\chan.c	/^	Sem_T send, recv, sync;$/;"	m	struct:T	file:
temp	.\src\mp.c	/^static unsigned char temp[16 + 16 + 16 + 2*16+2];$/;"	v	file:
testalert	.\src\thread-nt.c	/^static void testalert(T t) {$/;"	f	file:
testalert	.\src\thread.c	/^static void testalert(void) {$/;"	f	file:
textcmp	.\examples\cref.c	/^int textcmp(const void *x, const void *y) {$/;"	f
textcmp	.\examples\iref.c	/^int textcmp(const void *x, const void *y) {$/;"	f
texthash	.\examples\cref.c	/^unsigned texthash(const void *x) {$/;"	f
texthash	.\examples\iref.c	/^unsigned texthash(const void *x) {$/;"	f
timestamp	.\src\set.c	/^	unsigned timestamp;$/;"	m	struct:T	file:
timestamp	.\src\table.c	/^	unsigned timestamp;$/;"	m	struct:T	file:
tmp	.\src\mp.c	/^static T tmp[] = {temp, temp+1*16, temp+2*16, temp+3*16};$/;"	v	file:
u	.\examples\mpcalc.c	/^  u = { "%U\\n",$/;"	v	typeref:struct:__anon1
ub	.\examples\sort.c	/^	int lb, ub;$/;"	m	struct:args	file:
unsafe	.\examples\spin.c	/^int unsafe(void *cl) {$/;"	f
va_list_box	.\include\fmt.h	/^typedef struct va_list_box {$/;"	s
va_list_box	.\include\fmt.h	/^} va_list_box;$/;"	t	typeref:struct:va_list_box
value	.\src\ring.c	/^		void *value;$/;"	m	struct:T::node	file:
value	.\src\table.c	/^		void *value;$/;"	m	struct:T::binding	file:
vfree	.\examples\wf.c	/^void vfree(const void *key, void **count, void *cl) {$/;"	f
wf	.\examples\wf.c	/^void wf(char *name, FILE *fp) {$/;"	f
words	.\src\bit.c	/^	unsigned long *words;$/;"	m	struct:T	file:
x	.\src\mp.c	/^static int apply(T op(T, T, T), T z, T x, long v) {$/;"	v	file:
x	.\src\mp.c	/^static int applyu(T op(T, T, T), T z, T x,$/;"	v	file:
x	.\src\stack.c	/^		void *x;$/;"	m	struct:T::elem	file:
xref	.\examples\xref.c	/^void xref(const char *name, FILE *fp,$/;"	f
xx	.\misc\maxalign.c	48;"	d	file:
xx	.\misc\maxalign.c	50;"	d	file:
xx	.\misc\maxalign.c	54;"	d	file:
xx	.\misc\maxalign.c	56;"	d	file:
yy	.\misc\maxalign.c	37;"	d	file:
z	.\src\mp.c	/^static int apply(T op(T, T, T), T z, T x, long v) {$/;"	v	file:
z	.\src\mp.c	/^static int applyu(T op(T, T, T), T z, T x,$/;"	v	file:
