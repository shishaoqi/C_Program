!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
AddERef	.\set.c	/^static void AddERef(setADT set, void *ep)$/;"	f	file:
AddElementToIterator	.\set.c	/^static void AddElementToIterator(void *np, void *clientData)$/;"	f	file:
AddElementToIterator	.\symtab.c	/^static void AddElementToIterator(string key, void *value, void *clientData)$/;"	f	file:
AddIntElement	.\set.c	/^void AddIntElement(setADT set, int element)$/;"	f
AddPtrElement	.\set.c	/^void AddPtrElement(setADT set, void *element)$/;"	f
AddToIteratorList	.\iterator2.c	/^void AddToIteratorList(iteratorADT iterator, void *ep)$/;"	f
BSTData	.\bst.c	/^static bstDataT *BSTData(bstADT bst, treeT t)$/;"	f	file:
BSTData	.\bst_save.c	/^static bstDataT *BSTData(bstADT bst, treeT t)$/;"	f	file:
BSTLeftChild	.\bst.c	/^void *BSTLeftChild(bstADT bst, void *np)$/;"	f
BSTLeftChild	.\bst_save.c	/^void *BSTLeftChild(bstADT bst, void *np)$/;"	f
BSTRightChild	.\bst.c	/^void *BSTRightChild(bstADT bst, void *np)$/;"	f
BSTRightChild	.\bst_save.c	/^void *BSTRightChild(bstADT bst, void *np)$/;"	f
BSTRoot	.\bst.c	/^void *BSTRoot(bstADT bst)$/;"	f
BSTRoot	.\bst_save.c	/^void *BSTRoot(bstADT bst)$/;"	f
CharCmpFn	.\cmpfn.c	/^int CharCmpFn(const void *p1, const void *p2)$/;"	f
CharExchFn	.\cmpfn.c	/^void CharExchFn(void *p1, void *p2)$/;"	f
CharToString	.\strlib.c	/^string CharToString(char ch)$/;"	f
Class	.\set.c	/^	setClassT Class;$/;"	m	struct:setCDT	file:
Concat	.\strlib.c	/^string Concat(string s1, string s2)$/;"	f
ConvertToLowerCase	.\strlib.c	/^string ConvertToLowerCase(string s)$/;"	f
ConvertToUpperCase	.\strlib.c	/^string ConvertToUpperCase(string s)$/;"	f
CopyString	.\strlib.c	/^string CopyString(string s)$/;"	f
CreateString	.\strlib.c	/^static string CreateString(int len)$/;"	f	file:
DeleteBSTNode	.\bst.c	/^bool DeleteBSTNode(bstADT bst, void *kp)$/;"	f
DeleteBSTNode	.\bst_save.c	/^bool DeleteBSTNode(bstADT bst, void *kp)$/;"	f
DeleteERef	.\set.c	/^static void DeleteERef(setADT set, void *ep)$/;"	f	file:
DeleteIntElement	.\set.c	/^void DeleteIntElement(setADT set, int element)$/;"	f
DeletePtrElement	.\set.c	/^void DeletePtrElement(setADT set, void *element)$/;"	f
Delete_FixLeftImbalance	.\bst_save.c	/^static int Delete_FixLeftImbalance(bstADT bst, treeT *tptr)$/;"	f	file:
Delete_FixRightImbalance	.\bst_save.c	/^static int Delete_FixRightImbalance(bstADT bst, treeT *tptr)$/;"	f	file:
Dequeue	.\queue.c	/^queueElementT Dequeue(queueADT queue){$/;"	f
Dequeue	.\queuelist.c	/^queueElementT Dequeue(queueADT queue){$/;"	f
DoubleCmpFn	.\cmpfn.c	/^int DoubleCmpFn(const void *p1, const void *p2)$/;"	f
DoubleExchFn	.\cmpfn.c	/^void DoubleExchFn(void *p1, void *p2)$/;"	f
EnableIteration	.\iterator2.c	/^void EnableIteration(void *collection, newIteratorFnT newFn)$/;"	f
Enqueue	.\queue.c	/^void Enqueue(queueADT queue, queueElementT element)$/;"	f
Enqueue	.\queuelist.c	/^void Enqueue(queueADT queue, queueElementT element){$/;"	f
Enter	.\symtab.c	/^void Enter(symtabADT table, string key, void *value)$/;"	f
Error	.\genlib.c	/^void Error(string msg, ...)$/;"	f
ErrorExitStatus	.\genlib.c	23;"	d	file:
ExpandStack	.\stack.c	/^static void ExpandStack(stackADT stack)$/;"	f	file:
FALSE	.\genlib.h	/^       typedef enum {FALSE, TRUE} bool;$/;"	e	enum:__anon8
FALSE	.\genlib.h	58;"	d
FindBSTNode	.\bst.c	/^void *FindBSTNode(bstADT bst, void *kp)$/;"	f
FindBSTNode	.\bst_save.c	/^void *FindBSTNode(bstADT bst, void *kp)$/;"	f
FindCell	.\symtab.c	/^static cellT *FindCell(cellT *cp, string key)$/;"	f	file:
FindChar	.\strlib.c	/^int FindChar(char ch, string text, int start)$/;"	f
FindString	.\strlib.c	/^int FindString(string str, string text, int start)$/;"	f
FixLeftImbalance	.\bst.c	/^static void FixLeftImbalance(bstADT bst, treeT *tptr)$/;"	f	file:
FixLeftImbalance	.\bst_save.c	/^static void FixLeftImbalance(bstADT bst, treeT *tptr)$/;"	f	file:
FixRightImbalance	.\bst.c	/^static void FixRightImbalance(bstADT bst, treeT *tptr)$/;"	f	file:
FixRightImbalance	.\bst_save.c	/^static void FixRightImbalance(bstADT bst, treeT *tptr)$/;"	f	file:
FloatCmpFn	.\cmpfn.c	/^int FloatCmpFn(const void *p1, const void *p2)$/;"	f
FloatExchFn	.\cmpfn.c	/^void FloatExchFn(void *p1, void *p2)$/;"	f
FreeBST	.\bst.c	/^void FreeBST(bstADT bst, nodeFnT freeNodeFn)$/;"	f
FreeBST	.\bst_save.c	/^void FreeBST(bstADT bst, nodeFnT freeNodeFn)$/;"	f
FreeBlock	.\genlib.c	/^void FreeBlock(void *ptr)$/;"	f
FreeBucketChain	.\symtab.c	/^static void FreeBucketChain(cellT *cp)$/;"	f	file:
FreeIterator	.\iterator1.c	/^void FreeIterator(iteratorADT iterator)$/;"	f
FreeIterator	.\iterator2.c	/^void FreeIterator(iteratorADT iterator)$/;"	f
FreeNodeFn	.\set.c	/^static void FreeNodeFn(void *np, void *clientData)$/;"	f	file:
FreeQueue	.\queue.c	/^void FreeQueue(queueADT queue){$/;"	f
FreeQueue	.\queuelist.c	/^void FreeQueue(queueADT queue){$/;"	f
FreeSet	.\set.c	/^void FreeSet(setADT set)$/;"	f
FreeStack	.\stack.c	/^void FreeStack(stackADT stack)$/;"	f
FreeStack	.\stacklist.c	/^void FreeStack(stackADT stack)$/;"	f
FreeSymbolTable	.\symtab.c	/^void FreeSymbolTable(symtabADT table)$/;"	f
Freescanner	.\scanadt.c	/^void Freescanner(scannerADT scanner)$/;"	f
GetBlock	.\genlib.c	/^void *GetBlock(size_t nbytes)$/;"	f
GetCompareFunction	.\set.c	/^cmpFnT GetCompareFunction(setADT set)$/;"	f
GetInteger	.\simpio.c	/^int GetInteger(void)$/;"	f
GetLine	.\simpio.c	/^string GetLine(void)$/;"	f
GetLong	.\simpio.c	/^long GetLong(void)$/;"	f
GetQueueElement	.\queue.c	/^queueElementT GetQueueElement(queueADT queue, int index){$/;"	f
GetQueueElement	.\queuelist.c	/^queueElementT GetQueueElement(queueADT queue, int index)$/;"	f
GetReal	.\simpio.c	/^double GetReal(void)$/;"	f
GetScannerSpaceOption	.\scanadt.c	/^spaceOptionT GetScannerSpaceOption(scannerADT scanner)$/;"	f
GetSetClass	.\set.c	/^setClassT GetSetClass(setADT set)$/;"	f
GetStackElement	.\stack.c	/^stackElementT GetStackElement(stackADT stack, int index)$/;"	f
GetStackElement	.\stacklist.c	/^stackElementT GetStackElement(stackADT stack, int index)$/;"	f
Hash	.\symtab.c	/^static int Hash(string s, int nBuckets)$/;"	f	file:
IgnoreSpaces	.\scanadt.h	/^typedef enum {PreserveSpaces, IgnoreSpaces} spaceOptionT;$/;"	e	enum:__anon2
InOrder	.\bst.h	/^typedef enum { InOrder, PreOrder, PostOrder } OrderT;$/;"	e	enum:__anon1
InitSetNodeFn	.\set.c	/^static void InitSetNodeFn(void *np, void *kp, void *clientData)$/;"	f	file:
InitialBufferSize	.\simpio.c	22;"	d	file:
InitialStackSize	.\stack.c	9;"	d	file:
InsertBSTNode	.\bst.c	/^int InsertBSTNode(bstADT bst, void *kp, void *clientData)$/;"	f
InsertBSTNode	.\bst_save.c	/^int InsertBSTNode(bstADT bst, void *kp, void *clientData)$/;"	f
InsertKey	.\iterator1.c	/^static void InsertKey(string key, void *value, void *clientData)$/;"	f	file:
IntCmpFn	.\cmpfn.c	/^int IntCmpFn(const void *p1, const void *p2)$/;"	f
IntExchFn	.\cmpfn.c	/^void IntExchFn(void *p1, void *p2)$/;"	f
IntSet	.\set.h	/^typedef enum { IntSet, PtrSet } setClassT;$/;"	e	enum:__anon6
IntegerToString	.\strlib.c	/^string IntegerToString(int n)$/;"	f
Intersection	.\set.c	/^setADT Intersection(setADT s1, setADT s2)$/;"	f
IsIntElement	.\set.c	/^bool IsIntElement(setADT set, int element)$/;"	f
IsPtrment	.\set.c	/^bool IsPtrment(setADT set, void *element)$/;"	f
IsSubset	.\set.c	/^bool IsSubset(setADT s1, setADT s2)$/;"	f
IteratorPassword	.\iterator2.c	23;"	d	file:
IthChar	.\strlib.c	/^char IthChar(string s, int i)$/;"	f
LongCmpFn	.\cmpfn.c	/^int LongCmpFn(const void *p1, const void *p2)$/;"	f
LongExchFn	.\cmpfn.c	/^void LongExchFn(void *p1, void *p2)$/;"	f
LonglongCmpFn	.\cmpfn.c	/^int LonglongCmpFn(const void *p1, const void *p2)$/;"	f
Lookup	.\symtab.c	/^void *Lookup(symtabADT table, string key)$/;"	f
MapBST	.\bst.c	/^void MapBST(nodeFnT fn, bstADT bst, OrderT order, void *clientData)$/;"	f
MapBST	.\bst_save.c	/^void MapBST(nodeFnT fn, bstADT bst, OrderT order, void *clientData)$/;"	f
MapSymbolTable	.\symtab.c	/^void MapSymbolTable(symtabFnT fn, symtabADT table, void *clientData)$/;"	f
MaxDigits	.\strlib.c	34;"	d	file:
MaxQueueSize	.\queue.c	18;"	d	file:
MoreTokensExist	.\scanadt.c	/^bool MoreTokensExist(scannerADT scanner)$/;"	f
Multiplier	.\symtab.c	179;"	d	file:
NBuckets	.\symtab.c	17;"	d	file:
NElements	.\set.c	/^int NElements(setADT set)$/;"	f
New	.\genlib.h	153;"	d
NewArray	.\genlib.h	163;"	d
NewBST	.\bst.c	/^bstADT NewBST(int size, cmpFnT cmpFn, nodeInitFnT nodeInitFn)$/;"	f
NewBST	.\bst_save.c	/^bstADT NewBST(int size, cmpFnT cmpFn, nodeInitFnT nodeInitFn)$/;"	f
NewIntSet	.\set.c	/^setADT NewIntSet(void)$/;"	f
NewIterator	.\iterator1.c	/^iteratorADT NewIterator(symtabADT table)$/;"	f
NewIterator	.\iterator2.c	/^iteratorADT NewIterator(void *collection)$/;"	f
NewIteratorList	.\iterator2.c	/^iteratorADT NewIteratorList(int size, cmpFnT cmpFn)$/;"	f
NewPtrSet	.\set.c	/^setADT NewPtrSet(cmpFnT cmpFn)$/;"	f
NewQueue	.\queue.c	/^queueADT NewQueue(void){$/;"	f
NewQueue	.\queuelist.c	/^queueADT NewQueue(void){$/;"	f
NewRefBool	.\ref.c	/^void *NewRefBool(bool value)$/;"	f
NewRefChar	.\ref.c	/^void *NewRefChar(char value)$/;"	f
NewRefDouble	.\ref.c	/^void *NewRefDouble(double value)$/;"	f
NewRefFloat	.\ref.c	/^void *NewRefFloat(float value)$/;"	f
NewRefInt	.\ref.c	/^void *NewRefInt(int value)$/;"	f
NewRefLong	.\ref.c	/^void *NewRefLong(long value)$/;"	f
NewRefShort	.\ref.c	/^void *NewRefShort(short value)$/;"	f
NewRefUnsignedChar	.\ref.c	/^void *NewRefUnsignedChar(unsigned char value)$/;"	f
NewRefUnsignedLong	.\ref.c	/^void *NewRefUnsignedLong(unsigned long value)$/;"	f
NewRefUnsignedShort	.\ref.c	/^void *NewRefUnsignedShort(unsigned short value)$/;"	f
NewScanner	.\scanadt.c	/^scannerADT NewScanner(void)$/;"	f
NewSet	.\set.c	/^static setADT NewSet(setClassT Class, cmpFnT cmpFn)$/;"	f	file:
NewSetIterator	.\set.c	/^static iteratorADT NewSetIterator(void *collection)$/;"	f	file:
NewStack	.\stack.c	/^stackADT NewStack(void)$/;"	f
NewStack	.\stacklist.c	/^stackADT NewStack(void)$/;"	f
NewSymbolTable	.\symtab.c	/^symtabADT NewSymbolTable(void)$/;"	f
NewSymtabIterator	.\symtab.c	/^static iteratorADT NewSymtabIterator(void *collection)$/;"	f	file:
OrderT	.\bst.h	/^typedef enum { InOrder, PreOrder, PostOrder } OrderT;$/;"	t	typeref:enum:__anon1
Pop	.\stack.c	/^stackElementT Pop(stackADT stack)$/;"	f
Pop	.\stacklist.c	/^stackElementT Pop(stackADT stack)$/;"	f
PostOrder	.\bst.h	/^typedef enum { InOrder, PreOrder, PostOrder } OrderT;$/;"	e	enum:__anon1
PreOrder	.\bst.h	/^typedef enum { InOrder, PreOrder, PostOrder } OrderT;$/;"	e	enum:__anon1
PreserveSpaces	.\scanadt.h	/^typedef enum {PreserveSpaces, IgnoreSpaces} spaceOptionT;$/;"	e	enum:__anon2
PtrSet	.\set.h	/^typedef enum { IntSet, PtrSet } setClassT;$/;"	e	enum:__anon6
Push	.\stack.c	/^void Push(stackADT stack, stackElementT element)$/;"	f
Push	.\stacklist.c	/^void Push(stackADT stack, stackElementT element)$/;"	f
QueueArraySize	.\queue.c	19;"	d	file:
QueueIsEmpty	.\queue.c	/^bool QueueIsEmpty (queueADT queue)$/;"	f
QueueIsEmpty	.\queuelist.c	/^bool QueueIsEmpty(queueADT queue){$/;"	f
QueueIsFull	.\queue.c	/^bool QueueIsFull(queueADT queue){$/;"	f
QueueIsFull	.\queuelist.c	/^bool QueueIsFull(queueADT queue){$/;"	f
QueueLength	.\queue.c	/^int QueueLength (queueADT queue){$/;"	f
QueueLength	.\queuelist.c	/^int QueueLength(queueADT queue)$/;"	f
R	.\bst.c	/^  int R;$/;"	m	struct:deleteE	file:
R	.\bst_save.c	/^  int R;$/;"	m	struct:deleteE	file:
RAND_MAX	.\random.h	26;"	d
RandomChance	.\random.c	/^bool RandomChance(double p)$/;"	f
RandomInteger	.\random.c	/^int RandomInteger(int low, int high)$/;"	f
RandomReal	.\random.c	/^double RandomReal(double low, double high)$/;"	f
Randomize	.\random.c	/^void Randomize(void)$/;"	f
ReadLine	.\simpio.c	/^string ReadLine(FILE *infile)$/;"	f
ReadToken	.\scanadt.c	/^string ReadToken(scannerADT scanner)$/;"	f
RealToString	.\strlib.c	/^string RealToString(double d)$/;"	f
RecDeleteNode	.\bst.c	/^static deleteT RecDeleteNode(bstADT bst, treeT *tptr, void *kp, deleteT delta)$/;"	f	file:
RecDeleteNode	.\bst_save.c	/^static deleteT RecDeleteNode(bstADT bst, treeT *tptr, void *kp, deleteT delta)$/;"	f	file:
RecFindNode	.\bst.c	/^static treeT RecFindNode(bstADT bst, treeT t, void *kp)$/;"	f	file:
RecFindNode	.\bst_save.c	/^static treeT RecFindNode(bstADT bst, treeT t, void *kp)$/;"	f	file:
RecInsertNode	.\bst.c	/^static int RecInsertNode(bstADT bst, treeT *tptr, void *kp, void *clientData)$/;"	f	file:
RecInsertNode	.\bst_save.c	/^static int RecInsertNode(bstADT bst, treeT *tptr, void *kp, void *clientData)$/;"	f	file:
RecMapBST	.\bst.c	/^static void RecMapBST(nodeFnT fn, bstADT bst, treeT t,$/;"	f	file:
RecMapBST	.\bst_save.c	/^static void RecMapBST(nodeFnT fn, bstADT bst, treeT t,$/;"	f	file:
RefToBool	.\ref.c	/^bool RefToBool(void *ref) $/;"	f
RefToChar	.\ref.c	/^char RefToChar(void *ref)$/;"	f
RefToDouble	.\ref.c	/^double RefToDouble(void *ref)$/;"	f
RefToFloat	.\ref.c	/^float RefToFloat(void *ref)$/;"	f
RefToInt	.\ref.c	/^int RefToInt(void *ref)$/;"	f
RefToLong	.\ref.c	/^long RefToLong(void *ref)$/;"	f
RefToShort	.\ref.c	/^short RefToShort(void *ref)$/;"	f
RefToUnsigned	.\ref.c	/^unsigned RefToUnsigned(void *ref)$/;"	f
RefToUnsignedChar	.\ref.c	/^unsigned char RefToUnsignedChar(void *ref)$/;"	f
RefToUnsignedLong	.\ref.c	/^unsigned long RefToUnsignedLong(void *ref)$/;"	f
RefToUnsignedShort	.\ref.c	/^unsigned short RefToUnsignedShort(void *ref)$/;"	f
RotateLeft	.\bst.c	/^static void RotateLeft(bstADT bst, treeT *tptr)$/;"	f	file:
RotateLeft	.\bst_save.c	/^static void RotateLeft(bstADT bst, treeT *tptr)$/;"	f	file:
RotateRight	.\bst.c	/^static void RotateRight(bstADT bst, treeT *tptr)$/;"	f	file:
RotateRight	.\bst_save.c	/^static void RotateRight(bstADT bst, treeT *tptr)$/;"	f	file:
SaveToken	.\scanadt.c	/^void SaveToken(scannerADT scanner, string token)$/;"	f
ScanToEndOfIdentifier	.\scanadt.c	/^static int ScanToEndOfIdentifier(scannerADT scanner)$/;"	f	file:
SetDifference	.\set.c	/^setADT SetDifference(setADT s1, setADT s2)$/;"	f
SetEqual	.\set.c	/^bool SetEqual(setADT s1, setADT s2)$/;"	f
SetIsEmpty	.\set.c	/^bool SetIsEmpty(setADT set)$/;"	f
SetScannerSpaceOption	.\scanadt.c	/^void SetScannerSpaceOption(scannerADT scanner, spaceOptionT option)$/;"	f
SetScannerString	.\scanadt.c	/^void SetScannerString(scannerADT scanner, string str)$/;"	f
ShortCmpFn	.\cmpfn.c	/^int ShortCmpFn(const void *p1, const void *p2)$/;"	f
ShortExchFn	.\cmpfn.c	/^void ShortExchFn(void *p1, void *p2)$/;"	f
SkipSpaces	.\scanadt.c	/^static void SkipSpaces(scannerADT scanner)$/;"	f	file:
StackDepth	.\stack.c	/^int  StackDepth(stackADT stack)$/;"	f
StackDepth	.\stacklist.c	/^int  StackDepth(stackADT stack)$/;"	f
StackIsEmpty	.\stack.c	/^bool StackIsEmpty(stackADT stack)$/;"	f
StackIsEmpty	.\stacklist.c	/^bool StackIsEmpty(stackADT stack)$/;"	f
StackIsFull	.\stack.c	/^bool StackIsFull(stackADT stack)$/;"	f
StackIsFull	.\stacklist.c	/^bool StackIsFull(stackADT stack)$/;"	f
StepIterator	.\iterator1.c	/^bool StepIterator(iteratorADT iterator, string *pKey)$/;"	f
StepIterator	.\iterator2.c	/^bool StepIterator(iteratorADT iterator, void **ep)$/;"	f
Str	.\cmpfn.h	/^struct Str{$/;"	s
StringBox	.\cmpfn.h	/^typedef struct Str *StringBox;$/;"	t	typeref:struct:Str
StringCmpFn	.\cmpfn.c	/^int StringCmpFn(const void *p1, const void *p2)$/;"	f
StringCmpFn2	.\cmpfn.c	/^int StringCmpFn2(const void *p1, const void *p2)$/;"	f
StringCompare	.\strlib.c	/^int StringCompare(string s1, string s2)$/;"	f
StringEqual	.\strlib.c	/^bool StringEqual(string s1, string s2)$/;"	f
StringExchFn	.\cmpfn.c	/^void StringExchFn(void *p1, void *p2)$/;"	f
StringLength	.\strlib.c	/^int StringLength(string s)$/;"	f
StringToInteger	.\strlib.c	/^int StringToInteger(string s)$/;"	f
StringToReal	.\strlib.c	/^double StringToReal(string s)$/;"	f
SubString	.\strlib.c	/^string SubString(string s, int p1, int p2)$/;"	f
TRUE	.\genlib.h	/^       typedef enum {FALSE, TRUE} bool;$/;"	e	enum:__anon8
TRUE	.\genlib.h	59;"	d
TestERef	.\set.c	/^static bool TestERef(setADT set, void *ep)$/;"	f	file:
UNDEFINED	.\genlib.h	102;"	d
Union	.\set.c	/^setADT Union(setADT s1, setADT s2)$/;"	f
UnsignedExchFn	.\cmpfn.c	/^void UnsignedExchFn(void *p1, void *p2)$/;"	f
UnsignedIntCmpFn	.\cmpfn.c	/^int UnsignedIntCmpFn(const void *p1, const void *p2)$/;"	f
UnsignedLongCmpFn	.\cmpfn.c	/^int UnsignedLongCmpFn(const void *p1, const void *p2)$/;"	f
UnsignedLongExchFn	.\cmpfn.c	/^void UnsignedLongExchFn(void *p1, void *p2)$/;"	f
UnsignedLonglongCmpFn	.\cmpfn.c	/^int UnsignedLonglongCmpFn(const void *p1, const void *p2)$/;"	f
UnsignedShortCmpFn	.\cmpfn.c	/^int UnsignedShortCmpFn(const void *p1, const void *p2)$/;"	f
UnsignedShortExchFn	.\cmpfn.c	/^void UnsignedShortExchFn(void *p1, void *p2)$/;"	f
UnsortedFn	.\itertype.h	18;"	d
_bst_h	.\bst.h	10;"	d
_cmpfn_h	.\cmpfn.h	9;"	d
_genlib_h	.\genlib.h	28;"	d
_iterator1_h	.\iterator1.h	11;"	d
_iterator2_h	.\iterator2.h	11;"	d
_itertype_h	.\itertype.h	10;"	d
_queue_h	.\queue.h	11;"	d
_queuelist_h	.\queuelist.h	11;"	d
_random_h	.\random.h	11;"	d
_ref_h	.\ref.h	8;"	d
_scanadt_h	.\scanadt.h	13;"	d
_set_h	.\set.h	21;"	d
_simpio_h	.\simpio.h	11;"	d
_stack_h	.\stack.h	8;"	d
_stacklist_h	.\stacklist.h	8;"	d
_strlib_h	.\strlib.h	32;"	d
_symtab_h	.\symtab.h	8;"	d
bf	.\bst.c	/^  int bf;$/;"	m	struct:__anon5	file:
bf	.\bst_save.c	/^  int bf;$/;"	m	struct:__anon3	file:
bool	.\genlib.h	/^       typedef enum {FALSE, TRUE} bool;$/;"	t	typeref:enum:__anon8
bool	.\genlib.h	/^   typedef int bool;$/;"	t
bool	.\genlib.h	54;"	d
bst	.\set.c	/^	bstADT bst;$/;"	m	struct:setCDT	file:
bstADT	.\bst.h	/^typedef struct bstCDT *bstADT;$/;"	t	typeref:struct:bstCDT
bstCDT	.\bst.c	/^struct bstCDT {$/;"	s	file:
bstCDT	.\bst_save.c	/^struct bstCDT {$/;"	s	file:
bstDataT	.\bst.c	/^} bstDataT;$/;"	t	typeref:struct:__anon5	file:
bstDataT	.\bst_save.c	/^} bstDataT;$/;"	t	typeref:struct:__anon3	file:
buckets	.\symtab.c	/^  cellT *buckets[NBuckets];$/;"	m	struct:symtabCDT	file:
cellT	.\iterator1.c	/^typedef struct cellT{$/;"	s	file:
cellT	.\iterator1.c	/^} cellT;$/;"	t	typeref:struct:cellT	file:
cellT	.\iterator2.c	/^typedef struct cellT{$/;"	s	file:
cellT	.\iterator2.c	/^}cellT;$/;"	t	typeref:struct:cellT	file:
cellT	.\queuelist.c	/^typedef struct cellT{$/;"	s	file:
cellT	.\queuelist.c	/^} cellT;$/;"	t	typeref:struct:cellT	file:
cellT	.\stacklist.c	/^typedef struct cellT{$/;"	s	file:
cellT	.\stacklist.c	/^} cellT; $/;"	t	typeref:struct:cellT	file:
cellT	.\symtab.c	/^typedef struct cellT{$/;"	s	file:
cellT	.\symtab.c	/^}cellT;$/;"	t	typeref:struct:cellT	file:
cmpFn	.\bst.c	/^  cmpFnT cmpFn;$/;"	m	struct:bstCDT	file:
cmpFn	.\bst_save.c	/^  cmpFnT cmpFn;$/;"	m	struct:bstCDT	file:
cmpFn	.\iterator2.c	/^	cmpFnT cmpFn;$/;"	m	struct:iteratorCDT	file:
cmpFn	.\set.c	/^	cmpFnT cmpFn;$/;"	m	struct:setCDT	file:
cmpFnT	.\cmpfn.h	/^typedef int (*cmpFnT) (const void *p1, const void *p2);$/;"	t
count	.\stack.c	/^	int count;$/;"	m	struct:stackCDT	file:
cp	.\scanadt.c	/^	int cp;$/;"	m	struct:scannerCDT	file:
del	.\bst.c	/^static deleteT del(bstADT bst, treeT *tptr, treeT *ch, deleteT delta)$/;"	f	file:
deleteE	.\bst.c	/^struct deleteE{$/;"	s	file:
deleteE	.\bst_save.c	/^struct deleteE{$/;"	s	file:
deleteT	.\bst.h	/^typedef struct deleteE *deleteT;$/;"	t	typeref:struct:deleteE
element	.\stacklist.c	/^  stackElementT element;$/;"	m	struct:cellT	file:
elementSize	.\iterator2.c	/^	int elementSize;$/;"	m	struct:iteratorCDT	file:
elements	.\queue.c	/^	queueElementT elements[QueueArraySize];$/;"	m	struct:queueCDT	file:
elements	.\stack.c	/^	stackElementT* elements;$/;"	m	struct:stackCDT	file:
exchFnT	.\cmpfn.h	/^typedef void (*exchFnT) (void *p1, void *p2);$/;"	t
head	.\iterator2.c	/^	cellT *head, *tail;$/;"	m	struct:iteratorCDT	file:
head	.\queue.c	/^	int head;$/;"	m	struct:queueCDT	file:
head	.\queuelist.c	/^	cellT *head;$/;"	m	struct:queueCDT	file:
header	.\set.c	/^	iteratorHeaderT header;$/;"	m	struct:setCDT	file:
header	.\symtab.c	/^  iteratorHeaderT header;$/;"	m	struct:symtabCDT	file:
intRep	.\set.c	/^	int intRep;$/;"	m	union:__anon4	file:
iteratorADT	.\iterator1.h	/^typedef struct iteratorCDT *iteratorADT;$/;"	t	typeref:struct:iteratorCDT
iteratorADT	.\iterator2.h	/^typedef struct iteratorCDT *iteratorADT;$/;"	t	typeref:struct:iteratorCDT
iteratorCDT	.\iterator1.c	/^struct iteratorCDT{$/;"	s	file:
iteratorCDT	.\iterator2.c	/^struct iteratorCDT{$/;"	s	file:
iteratorHeaderT	.\itertype.h	/^}iteratorHeaderT;$/;"	t	typeref:struct:__anon7
key	.\iterator1.c	/^	string key;$/;"	m	struct:cellT	file:
key	.\symtab.c	/^	string key;$/;"	m	struct:cellT	file:
left	.\bst.c	/^  treeT left, right;$/;"	m	struct:__anon5	file:
left	.\bst_save.c	/^  treeT left, right;$/;"	m	struct:__anon3	file:
len	.\scanadt.c	/^	int len;$/;"	m	struct:scannerCDT	file:
link	.\iterator1.c	/^	struct cellT *link;$/;"	m	struct:cellT	typeref:struct:cellT::cellT	file:
link	.\iterator2.c	/^  struct cellT *link;$/;"	m	struct:cellT	typeref:struct:cellT::cellT	file:
link	.\queuelist.c	/^	struct cellT *link;$/;"	m	struct:cellT	typeref:struct:cellT::cellT	file:
link	.\stacklist.c	/^  struct cellT *link;$/;"	m	struct:cellT	typeref:struct:cellT::cellT	file:
link	.\symtab.c	/^	struct cellT *link;$/;"	m	struct:cellT	typeref:struct:cellT::cellT	file:
nElements	.\set.c	/^	int nElements;$/;"	m	struct:setCDT	file:
newFn	.\itertype.h	/^	newIteratorFnT newFn;$/;"	m	struct:__anon7
newIteratorFnT	.\itertype.h	/^typedef iteratorADT (*newIteratorFnT) (void *collection);$/;"	t
nodeFnT	.\bst.h	/^typedef void (*nodeFnT) (void *np, void *clientData);$/;"	t
nodeInitFn	.\bst.c	/^  nodeInitFnT nodeInitFn;$/;"	m	struct:bstCDT	file:
nodeInitFn	.\bst_save.c	/^  nodeInitFnT nodeInitFn;$/;"	m	struct:bstCDT	file:
nodeInitFnT	.\bst.h	/^typedef void (*nodeInitFnT) (void *np, void *kp, void *clientData);$/;"	t
password	.\itertype.h	/^	unsigned long password;$/;"	m	struct:__anon7
ptrRep	.\set.c	/^	void *ptrRep;$/;"	m	union:__anon4	file:
queueADT	.\queue.h	/^typedef struct queueCDT *queueADT;$/;"	t	typeref:struct:queueCDT
queueADT	.\queuelist.h	/^typedef struct queueCDT *queueADT;$/;"	t	typeref:struct:queueCDT
queueCDT	.\queue.c	/^struct queueCDT{$/;"	s	file:
queueCDT	.\queuelist.c	/^struct queueCDT{$/;"	s	file:
queueElementT	.\queue.h	/^typedef void *queueElementT;$/;"	t
queueElementT	.\queuelist.h	/^typedef char queueElementT;$/;"	t
repeat	.\genlib.h	204;"	d
right	.\bst.c	/^  treeT left, right;$/;"	m	struct:__anon5	file:
right	.\bst_save.c	/^  treeT left, right;$/;"	m	struct:__anon3	file:
root	.\bst.c	/^  treeT root;$/;"	m	struct:bstCDT	file:
root	.\bst_save.c	/^  treeT root;$/;"	m	struct:bstCDT	file:
s	.\cmpfn.h	/^  string s;$/;"	m	struct:Str
savedToken	.\scanadt.c	/^	string savedToken;$/;"	m	struct:scannerCDT	file:
scannerADT	.\scanadt.h	/^typedef struct scannerCDT *scannerADT;$/;"	t	typeref:struct:scannerCDT
scannerCDT	.\scanadt.c	/^struct scannerCDT{$/;"	s	file:
setADT	.\set.h	/^typedef struct setCDT *setADT;$/;"	t	typeref:struct:setCDT
setCDT	.\set.c	/^struct setCDT{$/;"	s	file:
setClassT	.\set.h	/^typedef enum { IntSet, PtrSet } setClassT;$/;"	t	typeref:enum:__anon6
setElementT	.\set.c	/^}setElementT;$/;"	t	typeref:union:__anon4	file:
size	.\stack.c	/^	int size;$/;"	m	struct:stackCDT	file:
spaceOption	.\scanadt.c	/^	spaceOptionT spaceOption;$/;"	m	struct:scannerCDT	file:
spaceOptionT	.\scanadt.h	/^typedef enum {PreserveSpaces, IgnoreSpaces} spaceOptionT;$/;"	t	typeref:enum:__anon2
stackADT	.\stack.h	/^typedef struct stackCDT *stackADT;$/;"	t	typeref:struct:stackCDT
stackADT	.\stacklist.h	/^typedef struct stackCDT *stackADT;$/;"	t	typeref:struct:stackCDT
stackCDT	.\stack.c	/^struct stackCDT{$/;"	s	file:
stackCDT	.\stacklist.c	/^struct stackCDT$/;"	s	file:
stackElementT	.\stack.h	/^typedef void* stackElementT;$/;"	t
stackElementT	.\stacklist.h	/^typedef void* stackElementT;$/;"	t
start	.\iterator1.c	/^	cellT *start;$/;"	m	struct:iteratorCDT	file:
start	.\stacklist.c	/^  cellT *start;$/;"	m	struct:stackCDT	file:
str	.\scanadt.c	/^	string str;$/;"	m	struct:scannerCDT	file:
stream	.\genlib.h	/^typedef FILE *stream;$/;"	t
string	.\genlib.h	/^typedef char *string;$/;"	t
symtabADT	.\symtab.h	/^typedef struct symtabCDT *symtabADT;$/;"	t	typeref:struct:symtabCDT
symtabCDT	.\symtab.c	/^struct symtabCDT{$/;"	s	file:
symtabFnT	.\symtab.h	/^typedef void (*symtabFnT) (string key, void *value, void *clientData);$/;"	t
tail	.\iterator2.c	/^	cellT *head, *tail;$/;"	m	struct:iteratorCDT	file:
tail	.\queue.c	/^	int tail;$/;"	m	struct:queueCDT	file:
tail	.\queuelist.c	/^	cellT *tail;$/;"	m	struct:queueCDT	file:
target	.\bst.c	/^  void *target;$/;"	m	struct:deleteE	file:
target	.\bst_save.c	/^  void *target;$/;"	m	struct:deleteE	file:
totalSize	.\bst.c	/^  int userSize, totalSize;$/;"	m	struct:bstCDT	file:
totalSize	.\bst_save.c	/^  int userSize, totalSize;$/;"	m	struct:bstCDT	file:
treeT	.\bst.c	/^typedef void *treeT;$/;"	t	file:
treeT	.\bst_save.c	/^typedef void *treeT;$/;"	t	file:
tree_height	.\bst_save.c	/^static int tree_height(bstADT bst, treeT root, int height)$/;"	f	file:
undefined_object	.\genlib.c	/^char undefined_object[] = "UNDEFINED";$/;"	v
userSize	.\bst.c	/^  int userSize, totalSize;$/;"	m	struct:bstCDT	file:
userSize	.\bst_save.c	/^  int userSize, totalSize;$/;"	m	struct:bstCDT	file:
value	.\queuelist.c	/^	queueElementT value;$/;"	m	struct:cellT	file:
value	.\symtab.c	/^	void *value;$/;"	m	struct:cellT	file:
